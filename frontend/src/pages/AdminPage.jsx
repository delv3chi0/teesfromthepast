// frontend/src/pages/AdminPage.jsx

import React, { useEffect, useState, useCallback, useRef } from 'react';
import {
    Box, Heading, Text, VStack, Tabs, TabList, TabPanels, Tab, TabPanel, Icon,
    Table, Thead, Tbody, Tr, Th, Td, TableContainer, Spinner, Alert, AlertIcon,
    Button, useToast, Tag, Image, Select,
    Modal, ModalOverlay, ModalContent, ModalHeader, ModalFooter, ModalBody, ModalCloseButton, useDisclosure,
    FormControl, FormLabel, Input, Switch, InputGroup, InputRightElement, IconButton,
    Divider, Tooltip, SimpleGrid, Stat, StatLabel, StatNumber, Flex,
    Accordion, AccordionItem, AccordionButton, AccordionPanel, AccordionIcon,
    Wrap, WrapItem, Radio, RadioGroup, NumberInput, NumberInputField, NumberInputStepper,
    NumberIncrementStepper, NumberDecrementStepper, Textarea, AlertDialog, AlertDialogBody,
    AlertDialogFooter, AlertDialogHeader, AlertDialogContent, CloseButton
} from '@chakra-ui/react';
import { FaUsersCog, FaBoxOpen, FaPalette, FaEdit, FaTrashAlt, FaEye, FaKey, FaEyeSlash, FaWarehouse, FaTachometerAlt, FaDollarSign, FaUserPlus, FaBoxes, FaPlus, FaStar, FaToggleOn, FaToggleOff } from 'react-icons/fa';
import { client } from '../api/client';
import { useAuth } from '../context/AuthProvider';

/**
 * Admin Console - DEFINITIVE, COMPLETE, & FULLY FUNCTIONAL
 * - This single file contains all logic for all admin panels.
 * - The Inventory Panel is a nested tab structure for Products, Types, and Categories.
 * - All components have been fully refactored for the dark theme.
 * - All previous bugs (StatCard crash, missing exports/definitions) are resolved.
 */

// --- Reusable Themed Inputs ---
const ThemedInput = (props) => <Input bg="brand.primaryDark" borderColor="whiteAlpha.300" _hover={{ borderColor: "whiteAlpha.400" }} focusBorderColor="brand.accentYellow" {...props} />;
const ThemedTextarea = (props) => <Textarea bg="brand.primaryDark" borderColor="whiteAlpha.300" _hover={{ borderColor: "whiteAlpha.400" }} focusBorderColor="brand.accentYellow" {...props} />;
const ThemedSelect = (props) => <Select bg="brand.primaryDark" borderColor="whiteAlpha.300" _hover={{ borderColor: "whiteAlpha.400" }} focusBorderColor="brand.accentYellow" {...props} />;
const ThemedNumberInput = (props) => (
    <NumberInput {...props}>
        <NumberInputField bg="brand.primaryDark" borderColor="whiteAlpha.300" _hover={{ borderColor: "whiteAlpha.400" }} focusBorderColor="brand.accentYellow" />
        <NumberInputStepper>
            <NumberIncrementStepper borderColor="whiteAlpha.300" _children={{ color: "whiteAlpha.800" }}/>
            <NumberDecrementStepper borderColor="whiteAlpha.300" _children={{ color: "whiteAlpha.800" }}/>
        </NumberInputStepper>
    </NumberInput>
);

// --- START PANEL SUB-COMPONENTS ---

const DashboardPanel = ({ token, onViewOrder }) => {
    const [summary, setSummary] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    useEffect(() => {
        const fetchSummary = async () => {
            if (!token) return; setLoading(true); setError('');
            try { const { data } = await client.get('/admin/orders/summary', { headers: { Authorization: `Bearer ${token}` } }); setSummary(data); } 
            catch (err) { setError('Could not load dashboard data.'); } 
            finally { setLoading(false); }
        };
        fetchSummary();
    }, [token]);

    const StatCard = ({ title, stat, icon, helpText }) => (
        <Box p={5} bg="brand.primaryLight" shadow="md" borderWidth="1px" borderColor="whiteAlpha.200" borderRadius="lg">
            <Stat>
                <Flex justifyContent="space-between">
                    <Box><StatLabel color="whiteAlpha.700">{title}</StatLabel><StatNumber color="brand.textLight">{stat}</StatNumber>{helpText && <Text fontSize="sm" color="whiteAlpha.600">{helpText}</Text>}</Box>
                    <Box my="auto" color="whiteAlpha.500"><Icon as={icon} w={8} h={8} /></Box>
                </Flex>
            </Stat>
        </Box>
    );

    if (loading) return <VStack justifyContent="center" alignItems="center" minH="300px"><Spinner size="xl" color="brand.accentYellow" /></VStack>;
    if (error) return <Alert status="error" bg="red.900" borderRadius="lg"><AlertIcon color="red.300"/>{error}</Alert>;
    if (!summary) return <Text p={4} color="whiteAlpha.800">No summary data available.</Text>;
    
    return (
        <VStack spacing={8} align="stretch" p={{ base: 2, md: 4 }}>
            <SimpleGrid columns={{ base: 1, md: 2, lg: 3 }} spacing={6}><StatCard title="Total Revenue" stat={`$${(summary.totalRevenue / 100).toFixed(2)}`} icon={FaDollarSign} helpText="All successful orders"/><StatCard title="Total Orders" stat={summary.totalOrders} icon={FaBoxes} helpText="All orders placed"/><StatCard title="New Users" stat={summary.newUserCount} icon={FaUserPlus} helpText="In the last 7 days"/></SimpleGrid>
            <Box><Heading size="lg" mb={4} color="brand.textLight">Recent Orders</Heading><TableContainer borderWidth="1px" borderRadius="lg" borderColor="whiteAlpha.200" bg="brand.primaryLight"><Table variant="simple" size="sm"><Thead><Tr><Th color="whiteAlpha.600">Order ID</Th><Th color="whiteAlpha.600">User</Th><Th color="whiteAlpha.600">Date</Th><Th isNumeric color="whiteAlpha.600">Total</Th><Th color="whiteAlpha.600">Status</Th><Th color="whiteAlpha.600">Actions</Th></Tr></Thead><Tbody color="brand.textLight">{summary.recentOrders.map(order => (<Tr key={order._id} _hover={{bg:"brand.headerBg"}}><Td fontSize="xs" title={order._id}>{order._id.substring(0,8)}...</Td><Td>{order.user?.email || 'N/A'}</Td><Td>{new Date(order.createdAt).toLocaleDateString()}</Td><Td isNumeric>${(order.totalAmount/100).toFixed(2)}</Td><Td><Tag size="sm" colorScheme={order.orderStatus === 'Delivered' ? 'green' : 'gray'}>{order.orderStatus}</Tag></Td><Td><Tooltip label="View Order Details" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" icon={<Icon as={FaEye} />} onClick={() => onViewOrder(order._id)}/></Tooltip></Td></Tr>))}</Tbody></Table></TableContainer></Box>
        </VStack>
    );
};

const ProductCategoryManager = ({ token }) => {
    const toast = useToast(); const [categories, setCategories] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(''); const [selectedCategory, setSelectedCategory] = useState(null); const [isEditing, setIsEditing] = useState(false); const [formData, setFormData] = useState({ name: '', description: '', isActive: true }); const { isOpen, onOpen, onClose } = useDisclosure(); const { isOpen: isDeleteOpen, onOpen: onDeleteOpen, onClose: onDeleteClose } = useDisclosure(); const cancelRef = useRef();
    const fetchCategories = useCallback(async () => { setLoading(true); setError(''); try { const { data } = await client.get('/admin/product-categories', { headers: { Authorization: `Bearer ${token}` } }); setCategories(data); } catch (err) { setError(err.response?.data?.message || 'Failed to fetch product categories.'); } finally { setLoading(false); } }, [token]);
    useEffect(() => { if (token) { fetchCategories(); } }, [fetchCategories, token]);
    const handleOpenModal = (category = null) => { if (category) { setIsEditing(true); setSelectedCategory(category); setFormData({ name: category.name, description: category.description || '', isActive: category.isActive }); } else { setIsEditing(false); setSelectedCategory(null); setFormData({ name: '', description: '', isActive: true }); } onOpen(); };
    const handleFormChange = (e) => { const { name, value, type, checked } = e.target; setFormData(prev => ({ ...prev, [name]: type === 'checkbox' || type === 'switch' ? checked : value })); };
    const handleSubmit = async () => { if (!formData.name.trim()) { toast({ title: "Validation Error", description: "Category name is required.", status: "error" }); return; } const method = isEditing ? 'put' : 'post'; const url = isEditing ? `/admin/product-categories/${selectedCategory._id}` : '/admin/product-categories'; try { await client[method](url, formData, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: `Category ${isEditing ? 'Updated' : 'Created'}`, status: "success" }); fetchCategories(); onClose(); } catch (err) { toast({ title: `Error ${isEditing ? 'Updating' : 'Creating'} Category`, description: err.response?.data?.message, status: "error" }); } };
    const handleOpenDeleteDialog = (category) => { setSelectedCategory(category); onDeleteOpen(); };
    const handleDelete = async () => { if (!selectedCategory) return; try { await client.delete(`/admin/product-categories/${selectedCategory._id}`, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "Category Deleted", status: "success" }); fetchCategories(); onDeleteClose(); } catch (err) { toast({ title: "Delete Failed", description: err.response?.data?.message, status: "error" }); onDeleteClose(); } };
    if (loading) return <VStack minH="200px" justify="center"><Spinner size="xl" color="brand.accentYellow" /></VStack>;
    if (error) return <Alert status="error" bg="red.900" borderRadius="lg"><AlertIcon color="red.300" />{error}</Alert>;
    return (<Box><HStack justifyContent="space-between" mb={6}><Heading size="lg" color="brand.textLight">Manage Categories</Heading><Button leftIcon={<Icon as={FaPlus} />} bg="brand.accentOrange" color="white" _hover={{bg:"brand.accentOrangeHover"}} onClick={() => handleOpenModal()}>Add Category</Button></HStack><TableContainer><Table variant="simple" size="sm" color="brand.textLight"><Thead><Tr><Th color="whiteAlpha.600">Name</Th><Th color="whiteAlpha.600">Description</Th><Th color="whiteAlpha.600">Status</Th><Th color="whiteAlpha.600">Actions</Th></Tr></Thead><Tbody>{categories.map((cat) => (<Tr key={cat._id} _hover={{bg:"brand.headerBg"}}><Td fontWeight="medium">{cat.name}</Td><Td fontSize="xs" maxW="300px" whiteSpace="normal">{cat.description || 'N/A'}</Td><Td><Tag size="sm" colorScheme={cat.isActive ? 'green' : 'red'} variant="subtle">{cat.isActive ? 'Active' : 'Inactive'}</Tag></Td><Td><Tooltip label="Edit Category" bg="brand.headerBg" color="white"><IconButton icon={<Icon as={FaEdit} />} size="sm" variant="ghost" onClick={() => handleOpenModal(cat)}/></Tooltip><Tooltip label="Delete Category" bg="brand.headerBg" color="white"><IconButton icon={<Icon as={FaTrashAlt} />} size="sm" variant="ghost" colorScheme="red" onClick={() => handleOpenDeleteDialog(cat)}/></Tooltip></Td></Tr>))}</Tbody></Table></TableContainer><Modal isOpen={isOpen} onClose={onClose} isCentered><ModalOverlay bg="blackAlpha.800"/><ModalContent bg="brand.primaryLight" color="brand.textLight"><ModalHeader borderBottomWidth="1px" borderColor="whiteAlpha.300">{isEditing ? 'Edit' : 'Add New'} Category</ModalHeader><ModalCloseButton _hover={{bg:"whiteAlpha.200"}}/><ModalBody py={6} as="form" id="category-form" onSubmit={(e)=>{e.preventDefault();handleSubmit();}}><VStack spacing={4}><FormControl isRequired><FormLabel>Category Name</FormLabel><ThemedInput name="name" value={formData.name} onChange={handleFormChange} placeholder="e.g., Men's Apparel" /></FormControl><FormControl><FormLabel>Description</FormLabel><ThemedInput name="description" value={formData.description} onChange={handleFormChange} placeholder="Brief description" /></FormControl><FormControl display="flex" alignItems="center"><FormLabel htmlFor="isActive-category" mb="0">Active</FormLabel><Switch id="isActive-category" name="isActive" isChecked={formData.isActive} onChange={handleFormChange} colorScheme="yellow" ml={3}/></FormControl></VStack></ModalBody><ModalFooter borderTopWidth="1px" borderColor="whiteAlpha.300"><Button variant="ghost" _hover={{bg:"whiteAlpha.200"}} mr={3} onClick={onClose}>Cancel</Button><Button type="submit" form="category-form" bg="brand.accentOrange" color="white" _hover={{bg:"brand.accentOrangeHover"}}>{isEditing ? 'Save Changes' : 'Create Category'}</Button></ModalFooter></ModalContent></Modal><AlertDialog isOpen={isDeleteOpen} onClose={onDeleteClose} isCentered leastDestructiveRef={cancelRef}><AlertDialogOverlay bg="blackAlpha.800" /><AlertDialogContent bg="brand.primaryLight" color="brand.textLight"><AlertDialogHeader>Confirm Deletion</AlertDialogHeader><AlertDialogBody>Delete <strong>{selectedCategory?.name}</strong>? This action cannot be undone.</AlertDialogBody><AlertDialogFooter><Button ref={cancelRef} variant="ghost" _hover={{bg:"whiteAlpha.200"}} onClick={onDeleteClose}>Cancel</Button><Button colorScheme="red" onClick={handleDelete} ml={3}>Delete</Button></AlertDialogFooter></AlertDialogContent></AlertDialog></Box>);
};

const ProductTypeManager = ({ token }) => {
    const toast = useToast(); const [productTypes, setProductTypes] = useState([]); const [categories, setCategories] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(''); const [selectedProductType, setSelectedProductType] = useState(null); const [isEditing, setIsEditing] = useState(false); const [formData, setFormData] = useState({ name: '', description: '', category: '', isActive: true }); const { isOpen, onOpen, onClose } = useDisclosure(); const { isOpen: isDeleteOpen, onOpen: onDeleteOpen, onClose: onDeleteClose } = useDisclosure(); const cancelRef = useRef();
    const fetchProductTypesAndCategories = useCallback(async () => { setLoading(true); setError(''); try { const [typesResponse, categoriesResponse] = await Promise.all([client.get('/admin/product-types', { headers: { Authorization: `Bearer ${token}` } }), client.get('/admin/product-categories', { headers: { Authorization: `Bearer ${token}` } })]); setProductTypes(typesResponse.data); setCategories(categoriesResponse.data.filter(cat => cat.isActive)); } catch (err) { setError(err.response?.data?.message || 'Failed to fetch data.'); } finally { setLoading(false); } }, [token]);
    useEffect(() => { if (token) { fetchProductTypesAndCategories(); } }, [fetchProductTypesAndCategories, token]);
    const handleOpenModal = (productType = null) => { if (productType) { setIsEditing(true); setSelectedProductType(productType); setFormData({ name: productType.name, description: productType.description || '', category: productType.category?._id || '', isActive: productType.isActive, }); } else { setIsEditing(false); setSelectedProductType(null); setFormData({ name: '', description: '', category: categories.length > 0 ? categories[0]._id : '', isActive: true }); } onOpen(); };
    const handleFormChange = (e) => { const { name, value, type, checked } = e.target; setFormData(prev => ({ ...prev, [name]: type === 'checkbox' || type === 'switch' ? checked : value })); };
    const handleSubmit = async () => { if (!formData.name.trim() || !formData.category) { toast({ title: "Validation Error", description: "Name and Category are required.", status: "error" }); return; } const method = isEditing ? 'put' : 'post'; const url = isEditing ? `/admin/product-types/${selectedProductType._id}` : '/admin/product-types'; try { await client[method](url, formData, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: `Product Type ${isEditing ? 'Updated' : 'Created'}`, status: "success" }); fetchProductTypesAndCategories(); onClose(); } catch (err) { toast({ title: `Error ${isEditing ? 'Updating' : 'Creating'} Product Type`, description: err.response?.data?.message, status: "error" }); } };
    const handleOpenDeleteDialog = (productType) => { setSelectedProductType(productType); onDeleteOpen(); };
    const handleDelete = async () => { if (!selectedProductType) return; try { await client.delete(`/admin/product-types/${selectedProductType._id}`, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "Product Type Deleted", status: "success" }); fetchProductTypesAndCategories(); onDeleteClose(); } catch (err) { toast({ title: "Delete Failed", description: err.response?.data?.message, status: "error" }); onDeleteClose(); } };
    if (loading) return <VStack minH="200px" justify="center"><Spinner size="xl" color="brand.accentYellow" /></VStack>;
    if (error && productTypes.length === 0) return <Alert status="error" bg="red.900" borderRadius="lg"><AlertIcon color="red.300" />{error}</Alert>;
    return (<Box><HStack justifyContent="space-between" mb={6}><Heading size="lg" color="brand.textLight">Manage Product Types</Heading><Button leftIcon={<Icon as={FaPlus} />} bg="brand.accentOrange" color="white" _hover={{bg:"brand.accentOrangeHover"}} onClick={() => handleOpenModal()} isDisabled={categories.length === 0}>Add New Type</Button></HStack>{categories.length === 0 && !loading && <Alert status="warning" mb={4} bg="yellow.900" borderColor="yellow.500" borderWidth="1px" borderRadius="lg"><AlertIcon color="yellow.400" />Please add Product Categories first before adding Product Types.</Alert>}<TableContainer><Table variant="simple" size="sm" color="brand.textLight"><Thead><Tr><Th color="whiteAlpha.600">Name</Th><Th color="whiteAlpha.600">Category</Th><Th color="whiteAlpha.600">Description</Th><Th color="whiteAlpha.600">Status</Th><Th color="whiteAlpha.600">Actions</Th></Tr></Thead><Tbody>{productTypes.map((pt) => (<Tr key={pt._id} _hover={{bg:"brand.headerBg"}}><Td fontWeight="medium">{pt.name}</Td><Td>{pt.category?.name || 'N/A'}</Td><Td fontSize="xs" maxW="300px" whiteSpace="normal">{pt.description || 'N/A'}</Td><Td><Tag size="sm" colorScheme={pt.isActive ? 'green' : 'red'} variant="subtle">{pt.isActive ? 'Active' : 'Inactive'}</Tag></Td><Td><Tooltip label="Edit Type" bg="brand.headerBg" color="white"><IconButton icon={<Icon as={FaEdit} />} size="sm" variant="ghost" onClick={() => handleOpenModal(pt)}/></Tooltip><Tooltip label="Delete Type" bg="brand.headerBg" color="white"><IconButton icon={<Icon as={FaTrashAlt} />} size="sm" variant="ghost" colorScheme="red" onClick={() => handleOpenDeleteDialog(pt)}/></Tooltip></Td></Tr>))}</Tbody></Table></TableContainer><Modal isOpen={isOpen} onClose={onClose} isCentered><ModalOverlay bg="blackAlpha.800"/><ModalContent bg="brand.primaryLight" color="brand.textLight"><ModalHeader borderBottomWidth="1px" borderColor="whiteAlpha.300">{isEditing ? 'Edit' : 'Add New'} Product Type</ModalHeader><ModalCloseButton _hover={{bg:"whiteAlpha.200"}}/><ModalBody py={6} as="form" id="type-form" onSubmit={(e)=>{e.preventDefault();handleSubmit();}}><VStack spacing={4}><FormControl isRequired><FormLabel>Type Name</FormLabel><ThemedInput name="name" value={formData.name} onChange={handleFormChange} placeholder="e.g., T-Shirt, Hoodie"/></FormControl><FormControl isRequired><FormLabel>Category</FormLabel><ThemedSelect name="category" value={formData.category} onChange={handleFormChange} placeholder="Select category" isDisabled={categories.length === 0}>{categories.map(cat => (<option key={cat._id} value={cat._id}>{cat.name}</option>))}</ThemedSelect></FormControl><FormControl><FormLabel>Description</FormLabel><ThemedInput name="description" value={formData.description} onChange={handleFormChange} placeholder="Brief description"/></FormControl><FormControl display="flex" alignItems="center"><FormLabel htmlFor="isActive-type" mb="0">Active</FormLabel><Switch id="isActive-type" name="isActive" isChecked={formData.isActive} onChange={handleFormChange} colorScheme="yellow" ml={3}/></FormControl></VStack></ModalBody><ModalFooter borderTopWidth="1px" borderColor="whiteAlpha.300"><Button variant="ghost" _hover={{bg:"whiteAlpha.200"}} mr={3} onClick={onClose}>Cancel</Button><Button type="submit" form="type-form" bg="brand.accentOrange" color="white" _hover={{bg:"brand.accentOrangeHover"}} isDisabled={categories.length === 0 && !isEditing}>{isEditing ? 'Save Changes' : 'Create Type'}</Button></ModalFooter></ModalContent></Modal><AlertDialog isOpen={isDeleteOpen} onClose={onDeleteClose} isCentered leastDestructiveRef={cancelRef}><AlertDialogOverlay bg="blackAlpha.800" /><AlertDialogContent bg="brand.primaryLight" color="brand.textLight"><AlertDialogHeader>Confirm Deletion</AlertDialogHeader><AlertDialogBody>Delete <strong>{selectedProductType?.name}</strong>? This cannot be undone.</AlertDialogBody><AlertDialogFooter><Button ref={cancelRef} variant="ghost" _hover={{bg:"whiteAlpha.200"}} onClick={onDeleteClose}>Cancel</Button><Button colorScheme="red" onClick={handleDelete} ml={3}>Delete</Button></AlertDialogFooter></AlertDialogContent></AlertDialog></Box>);
};

const ProductManager = ({ token }) => {
    const toast = useToast(); const [products, setProducts] = useState([]); const [productTypes, setProductTypes] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(''); const [isModalLoading, setIsModalLoading] = useState(false); const [selectedProduct, setSelectedProduct] = useState(null); const [isEditing, setIsEditing] = useState(false); const [formData, setFormData] = useState({ name: '', description: '', productType: '', basePrice: 0, tags: '', isActive: true, variants: [] }); const [newColorData, setNewColorData] = useState({ colorName: '', colorHex: '', podProductId: '' }); const { isOpen, onOpen, onClose } = useDisclosure(); const { isOpen: isDeleteOpen, onOpen: onDeleteOpen, onClose: onDeleteClose } = useDisclosure(); const cancelRef = useRef();
    const fetchProducts = useCallback(async () => { setLoading(true); setError(''); try { const { data } = await client.get('/admin/products', { headers: { Authorization: `Bearer ${token}` } }); setProducts(data); } catch (err) { setError(err.response?.data?.message || 'Failed to fetch products.'); } finally { setLoading(false); } }, [token]);
    const fetchProductTypes = useCallback(async () => { if (!token) return; try { const { data } = await client.get('/admin/product-types', { headers: { Authorization: `Bearer ${token}` } }); setProductTypes(data); } catch (e) { toast({ title: "Error", description: "Could not load product types.", status: "error" }); } }, [token, toast]);
    useEffect(() => { if (token) { fetchProducts(); fetchProductTypes(); } }, [token, fetchProducts, fetchProductTypes]);
    const handleOpenModal = async (product = null) => { onOpen(); setIsModalLoading(true); try { const activeTypes = productTypes.filter(pt => pt.isActive); setNewColorData({ colorName: '', colorHex: '', podProductId: '' }); if (product) { const { data: fullProductData } = await client.get(`/admin/products/${product._id}`, { headers: { Authorization: `Bearer ${token}` }}); setIsEditing(true); setSelectedProduct(fullProductData); setFormData({ name: fullProductData.name, description: fullProductData.description || '', productType: fullProductData.productType?._id || fullProductData.productType || '', basePrice: fullProductData.basePrice || 0, tags: Array.isArray(fullProductData.tags) ? fullProductData.tags.join(', ') : '', isActive: fullProductData.isActive, variants: (fullProductData.variants || []).map(v => ({...v, imageSet: v.imageSet && v.imageSet.length > 0 ? v.imageSet : [{ url: '', isPrimary: true }], sizes: v.sizes || [] })) }); } else { setIsEditing(false); setSelectedProduct(null); setFormData({ name: '', description: '', productType: activeTypes.length > 0 ? activeTypes[0]._id : '', basePrice: 0, tags: '', isActive: true, variants: [] }); } } catch (err) { toast({ title: "Error", description: "Could not load data for the form.", status: "error" }); onClose(); } finally { setIsModalLoading(false); } };
    const handleFormChange = (e) => { const { name, value, type, checked } = e.target; setFormData(prev => ({ ...prev, [name]: type === 'checkbox' || type === 'switch' ? checked : value })); };
    const handleBasePriceChange = (valStr, valNum) => { setFormData(prev => ({ ...prev, basePrice: valNum || 0 })); };
    const handleNewColorFormChange = (e) => { const { name, value } = e.target; if (name === "colorName") { const sel = CORE_COLORS.find(c => c.name === value); setNewColorData(prev => ({ ...prev, colorName: value, colorHex: sel ? sel.hex : '' })); } else { setNewColorData(prev => ({ ...prev, [name]: value })); } };
    const handleAddColorVariant = () => { if (!newColorData.colorName) { toast({ title: "Color Name Required", status: "warning" }); return; } if (formData.variants.some(v => v.colorName === newColorData.colorName)) { toast({ title: "Duplicate Color", status: "warning" }); return; } const newVariant = { ...initialColorVariantState, ...newColorData, sizes: SIZES.map(s => ({ size: s, sku: `${(formData.name || 'PROD').substring(0, 5).toUpperCase().replace(/\s+/g, '')}-${newColorData.colorName.toUpperCase().replace(/[\s/]+/g, '')}-${s}`, inStock: true, priceModifier: 0 })) }; if (formData.variants.length === 0) { newVariant.isDefaultDisplay = true; } setFormData(prev => ({ ...prev, variants: [...prev.variants, newVariant] })); setNewColorData({ colorName: '', colorHex: '', podProductId: '' }); };
    const handleRemoveColorVariant = (colorIndex) => { const newVariants = [...formData.variants]; newVariants.splice(colorIndex, 1); if (newVariants.length > 0 && !newVariants.some(v => v.isDefaultDisplay)) { newVariants[0].isDefaultDisplay = true; } setFormData(prev => ({ ...prev, variants: newVariants })); };
    const handleSizeDetailChange = (colorIdx, sizeIdx, field, value) => { const newV = [...formData.variants]; newV[colorIdx].sizes[sizeIdx][field] = value; setFormData(prev => ({ ...prev, variants: newV })); };
    const handleImageSetUrlChange = (colorIndex, imageIndex, url) => { const newVariants = [...formData.variants]; newVariants[colorIndex].imageSet[imageIndex].url = url; setFormData(prev => ({ ...prev, variants: newVariants })); };
    const addImageToSet = (colorIndex) => { const newVariants = [...formData.variants]; newVariants[colorIndex].imageSet.push({ url: '', isPrimary: false }); setFormData(prev => ({ ...prev, variants: newVariants })); };
    const removeImageFromSet = (colorIndex, imageIndex) => { const newVariants = [...formData.variants]; if(newVariants[colorIndex].imageSet.length > 1) { newVariants[colorIndex].imageSet.splice(imageIndex, 1); if (!newVariants[colorIndex].imageSet.some(img => img.isPrimary)) { newVariants[colorIndex].imageSet[0].isPrimary = true; } setFormData(prev => ({ ...prev, variants: newVariants })); } };
    const setPrimaryImage = (colorIndex, imageIndex) => { const newVariants = [...formData.variants]; newVariants[colorIndex].imageSet.forEach((img, idx) => { img.isPrimary = idx === imageIndex; }); setFormData(prev => ({ ...prev, variants: newVariants })); };
    const setDefaultVariant = (colorIndexToSet) => { const newVariants = formData.variants.map((v, index) => ({ ...v, isDefaultDisplay: index === colorIndexToSet })); setFormData(prev => ({ ...prev, variants: newVariants })); };
    const handleSubmit = async () => { if (!formData.name.trim() || !formData.productType) { toast({ title: "Validation Error", description: "Product Name and Type are required.", status: "error" }); return; } for (const variant of formData.variants) { for (const image of variant.imageSet) { if (!image.url || image.url.trim() === '') { toast({ title: "Image URL Missing", description: `Please provide a URL for all images in the "${variant.colorName}" variant gallery.`, status: "error" }); return; } } } if (formData.variants.length > 0 && !formData.variants.some(v => v.isDefaultDisplay)) { formData.variants[0].isDefaultDisplay = true; } for (const variant of formData.variants) { if (variant.imageSet && !variant.imageSet.some(img => img.isPrimary)) { if(variant.imageSet.length > 0) variant.imageSet[0].isPrimary = true; } for (const size of variant.sizes) { if (size.inStock && !size.sku) { toast({ title: "Validation Error", description: `SKU missing for in-stock size ${size.size} in ${variant.colorName}.`, status: "error" }); return; } } } const method = isEditing ? 'put' : 'post'; const url = isEditing ? `/admin/products/${selectedProduct._id}` : '/admin/products'; const payload = { ...formData, tags: (formData.tags || '').split(',').map(tag => tag.trim()).filter(Boolean) }; try { await client[method](url, payload, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: `Product ${isEditing ? 'Updated' : 'Created'}`, status: "success" }); fetchProducts(); onClose(); } catch (err) { toast({ title: `Error Saving Product`, description: err.response?.data?.message, status: "error" }); } };
    const handleOpenDeleteDialog = (product) => { setSelectedProduct(product); onDeleteOpen(); };
    const handleDelete = async () => { if (!selectedProduct) return; try { await client.delete(`/admin/products/${selectedProduct._id}`, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "Product Deleted", status: "success" }); fetchProducts(); onDeleteClose(); } catch (err) { toast({ title: "Delete Failed", description: err.response?.data?.message, status: "error" }); onDeleteClose(); } };
    if (loading) return <VStack minH="200px" justify="center"><Spinner size="xl" color="brand.accentYellow" /></VStack>;
    if (error) return <Alert status="error" bg="red.900" borderRadius="lg"><AlertIcon color="red.300" />{error}</Alert>;
    return (<Box><HStack justifyContent="space-between" mb={6}><Heading size="lg" color="brand.textLight">Manage Products</Heading><Button leftIcon={<Icon as={FaPlus} />} bg="brand.accentOrange" color="white" _hover={{bg:"brand.accentOrangeHover"}} onClick={() => handleOpenModal()}>Add New Product</Button></HStack><TableContainer><Table variant="simple" size="sm" color="brand.textLight"><Thead><Tr><Th color="whiteAlpha.600">Name</Th><Th color="whiteAlpha.600">Type</Th><Th isNumeric color="whiteAlpha.600">Base Price</Th><Th color="whiteAlpha.600">Variants</Th><Th color="whiteAlpha.600">Status</Th><Th color="whiteAlpha.600">Actions</Th></Tr></Thead><Tbody>{products.map((p) => (<Tr key={p._id} _hover={{bg:"brand.headerBg"}}><Td fontWeight="medium">{p.name}</Td><Td>{productTypes.find(pt => pt._id === p.productType)?.name || 'N/A'}</Td><Td isNumeric>${p.basePrice?.toFixed(2)}</Td><Td>{p.variantCount !== undefined ? p.variantCount : '-'}</Td><Td><Tag colorScheme={p.isActive ? 'green' : 'red'} variant="subtle">{p.isActive ? 'Active' : 'Inactive'}</Tag></Td><Td><Tooltip label="Edit" bg="brand.headerBg" color="white"><IconButton icon={<Icon as={FaEdit}/>} size="sm" variant="ghost" onClick={() => handleOpenModal(p)}/></Tooltip><Tooltip label="Delete" bg="brand.headerBg" color="white"><IconButton icon={<Icon as={FaTrashAlt}/>} size="sm" variant="ghost" colorScheme="red" onClick={() => handleOpenDeleteDialog(p)}/></Tooltip></Td></Tr>))}</Tbody></Table></TableContainer><Modal isOpen={isOpen} onClose={onClose} size="6xl" scrollBehavior="inside"><ModalOverlay bg="blackAlpha.800" /><ModalContent bg="brand.primary" color="brand.textLight"><ModalHeader borderBottomWidth="1px" borderColor="whiteAlpha.300">{isEditing ? 'Edit' : 'Add New'} Product</ModalHeader><ModalCloseButton _hover={{bg:"whiteAlpha.200"}}/><ModalBody pb={6}><VStack spacing={6} align="stretch" p={2}>{isModalLoading ? <VStack minH="400px" justify="center"><Spinner size="xl" color="brand.accentYellow"/></VStack> : (<><Box p={4} borderWidth="1px" borderRadius="lg" borderColor="whiteAlpha.300" bg="brand.primaryLight"><Heading size="md" mb={4}>Product Details</Heading><SimpleGrid columns={{base: 1, md: 2}} spacing={4}><FormControl isRequired><FormLabel>Name</FormLabel><ThemedInput name="name" value={formData.name} onChange={handleFormChange}/></FormControl><FormControl isRequired><FormLabel>Product Type</FormLabel><ThemedSelect name="productType" value={formData.productType} onChange={handleFormChange} placeholder="Select type">{productTypes.map(pt => (<option key={pt._id} value={pt._id}>{pt.name}</option>))}</ThemedSelect></FormControl><FormControl isRequired><FormLabel>Base Price ($)</FormLabel><ThemedNumberInput value={formData.basePrice} onChange={handleBasePriceChange} min={0} precision={2}/></FormControl><FormControl><FormLabel>Tags (comma-separated)</FormLabel><ThemedInput name="tags" value={formData.tags} onChange={handleFormChange}/></FormControl></SimpleGrid><FormControl mt={4}><FormLabel>Description</FormLabel><ThemedTextarea name="description" value={formData.description} onChange={handleFormChange}/></FormControl><FormControl display="flex" alignItems="center" mt={4}><FormLabel mb="0" mr={4}>Active:</FormLabel><Switch name="isActive" isChecked={formData.isActive} onChange={handleFormChange} colorScheme="yellow"/></FormControl></Box><Box p={4} borderWidth="1px" borderRadius="lg" borderColor="whiteAlpha.300" bg="brand.primaryLight"><Heading size="md" mb={4}>Product Variants</Heading><RadioGroup onChange={(val) => setDefaultVariant(parseInt(val))} value={formData.variants.findIndex(v => v.isDefaultDisplay)?.toString() ?? "-1"}><VStack spacing={4} align="stretch">{(formData.variants || []).map((variant, colorIndex) => (variant && variant.sizes) ? <Accordion key={colorIndex} defaultIndex={[0]} allowToggle borderWidth="1px" borderRadius="lg" bg="brand.primaryDark" borderColor="whiteAlpha.300"><AccordionItem border="none"><Flex align="center" p={2}><Radio value={colorIndex.toString()} mr={3} colorScheme="yellow" borderColor="whiteAlpha.400"/><Tooltip label="Set as default display for shop page" bg="brand.headerBg" color="white"><Icon as={FaStar} color={variant.isDefaultDisplay ? "yellow.400" : "gray.500"} mr={2}/></Tooltip><AccordionButton flex="1" _hover={{bg:"brand.headerBg"}} borderRadius="md"><HStack w="full" spacing={4}><Box w="24px" h="24px" bg={variant.colorHex} borderRadius="full" border="1px solid" borderColor="gray.500"/><Text fontWeight="bold">{variant.colorName}</Text></HStack></AccordionButton><AccordionIcon /><CloseButton size="sm" onClick={() => handleRemoveColorVariant(colorIndex)} _hover={{bg:'red.600'}}/></Flex><AccordionPanel bg="brand.primary" pb={4}><FormControl><FormLabel fontSize="sm">POD Product ID</FormLabel><ThemedInput size="sm" value={variant.podProductId || ''} onChange={(e) => { const newV = [...formData.variants]; newV[colorIndex].podProductId = e.target.value; setFormData(p => ({...p, variants: newV})); }} /></FormControl><Divider my={4} borderColor="whiteAlpha.300" /><Heading size="sm" mb={3}>Image Gallery for {variant.colorName}</Heading><RadioGroup onChange={(idx) => setPrimaryImage(colorIndex, parseInt(idx))} value={variant.imageSet?.findIndex(img => img.isPrimary)?.toString() ?? "-1"}><VStack align="stretch" spacing={2}>{variant.imageSet?.map((img, imgIndex) => (<HStack key={imgIndex}><Radio value={imgIndex.toString()} colorScheme="green" borderColor="whiteAlpha.400"/><ThemedInput flex="1" size="sm" placeholder="https://image.url/shirt.png" value={img.url} onChange={(e) => handleImageSetUrlChange(colorIndex, imgIndex, e.target.value)} /><Image src={img.url} alt="Preview" boxSize="32px" objectFit="cover" borderRadius="sm" bg="brand.primaryDark" fallback={<Icon as={FaImage} color="gray.500" boxSize="32px" p={1}/>}/><IconButton size="sm" variant="ghost" colorScheme="red" icon={<Icon as={FaTrashAlt}/>} onClick={() => removeImageFromSet(colorIndex, imgIndex)} isDisabled={variant.imageSet.length <= 1} /></HStack>))}</VStack></RadioGroup><Button size="sm" mt={3} onClick={() => addImageToSet(colorIndex)} leftIcon={<Icon as={FaPlus}/>} bg="brand.accentYellow" color="brand.textDark" _hover={{bg:"brand.accentYellowHover"}}>Add Image</Button><Divider my={4} borderColor="whiteAlpha.300" /><Heading size="sm" mb={3}>Available Sizes</Heading><Wrap spacing={4}>{variant.sizes?.map((size, sizeIndex) => (<WrapItem key={size.size}><VStack p={2} borderWidth="1px" borderRadius="md" spacing={1} minW="180px" bg={size.inStock ? 'green.800' : 'red.900'} borderColor={size.inStock ? 'green.600':'red.600'}><HStack justifyContent="space-between" w="100%"><Text fontWeight="bold">{size.size}</Text><Switch size="sm" isChecked={size.inStock} onChange={e => handleSizeDetailChange(colorIndex, sizeIndex, 'inStock', e.target.checked)} colorScheme="yellow"/></HStack><FormControl isDisabled={!size.inStock}><FormLabel fontSize="xs">SKU</FormLabel><ThemedInput size="sm" value={size.sku} onChange={e => handleSizeDetailChange(colorIndex, sizeIndex, 'sku', e.target.value)}/></FormControl></VStack></WrapItem>))}</Wrap></AccordionPanel></AccordionItem></Accordion> : <Alert status="warning"><AlertIcon/>Corrupted variant data. Please remove and re-add this color.</Alert>))}</VStack></RadioGroup><Box p={4} borderWidth="1px" borderRadius="lg" mt={6} bg="brand.primaryDark"><Heading size="sm" mb={3}>Add New Color Variant</Heading><SimpleGrid columns={{ base: 1, md: 3 }} spacing={3}><FormControl><FormLabel fontSize="sm">Color Name</FormLabel><ThemedSelect size="sm" name="colorName" value={newColorData.colorName} onChange={handleNewColorFormChange} placeholder="Select...">{CORE_COLORS.map(c => <option key={c.name} value={c.name}>{c.name}</option>)}</ThemedSelect></FormControl><FormControl><FormLabel fontSize="sm">Color Hex</FormLabel><HStack><ThemedInput size="sm" name="colorHex" value={newColorData.colorHex} onChange={handleNewColorFormChange}/><Box w="24px" h="24px" bg={newColorData.colorHex} borderRadius="sm" border="1px solid" borderColor="whiteAlpha.400"/></HStack></FormControl><FormControl><FormLabel fontSize="sm">POD Product ID</FormLabel><ThemedInput size="sm" name="podProductId" value={newColorData.podProductId} onChange={handleNewColorFormChange}/></FormControl></SimpleGrid><Button mt={4} size="sm" bg="brand.accentOrange" color="white" _hover={{bg:"brand.accentOrangeHover"}} onClick={handleAddColorVariant} isDisabled={!newColorData.colorName}>Add This Color</Button></Box></Box></>)}</VStack></ModalBody><ModalFooter borderTopWidth="1px" borderColor="whiteAlpha.300"><Button variant="ghost" _hover={{bg:"whiteAlpha.200"}} mr={3} onClick={onClose}>Cancel</Button><Button bg="brand.accentOrange" color="white" _hover={{bg:'brand.accentOrangeHover'}} onClick={handleSubmit} isLoading={isModalLoading}>Save Changes</Button></ModalFooter></ModalContent></Modal>
            {selectedProduct && <AlertDialog isOpen={isDeleteOpen} onClose={onDeleteClose} isCentered leastDestructiveRef={cancelRef}><AlertDialogOverlay bg="blackAlpha.800"/><AlertDialogContent bg="brand.primaryLight" color="brand.textLight"><AlertDialogHeader>Confirm Deletion</AlertDialogHeader><AlertDialogBody>Delete <strong>{selectedProduct.name}</strong>?</AlertDialogBody><AlertDialogFooter><Button ref={cancelRef} variant="ghost" _hover={{bg:"whiteAlpha.200"}} onClick={onDeleteClose}>No</Button><Button colorScheme="red" onClick={handleDelete} ml={3}>Yes</Button></AlertDialogFooter></AlertDialogContent></AlertDialog>}
        </Box>
    );
};

// --- END INVENTORY COMPONENTS ---


// --- Main AdminPage Component ---
const AdminPage = () => {
    const { token } = useAuth();
    const toast = useToast();
    const [users, setUsers] = useState([]);
    const [loadingUsers, setLoadingUsers] = useState(false);
    const [usersError, setUsersError] = useState('');
    const [selectedUser, setSelectedUser] = useState(null);
    const [orders, setOrders] = useState([]);
    const [loadingOrders, setLoadingOrders] = useState(false);
    const [ordersError, setOrdersError] = useState('');
    const [selectedOrder, setSelectedOrder] = useState(null);
    const [loadingSelectedOrder, setLoadingSelectedOrder] = useState(false);
    const [designs, setDesigns] = useState([]);
    const [loadingDesigns, setLoadingDesigns] = useState(false);
    const [designsError, setDesignsError] = useState('');
    const [orderToDelete, setOrderToDelete] = useState(null);
    const [designToDelete, setDesignToDelete] = useState(null);
    const [selectedDesign, setSelectedDesign] = useState(null);
    const [tabIndex, setTabIndex] = useState(0);
    const { isOpen: isDeleteOrderModalOpen, onOpen: onDeleteOrderModalOpen, onClose: onDeleteOrderModalClose } = useDisclosure();
    const { isOpen: isViewUserModalOpen, onOpen: onViewUserModalOpen, onClose: onViewUserModalClose } = useDisclosure();
    const { isOpen: isEditModalOpen, onOpen: onEditModalOpen, onClose: onEditModalClose } = useDisclosure();
    const { isOpen: isDeleteUserModalOpen, onOpen: onDeleteUserModalOpen, onClose: onDeleteUserModalClose } = useDisclosure();
    const { isOpen: isViewOrderModalOpen, onOpen: onOpenViewOrderModal, onClose: onCloseViewOrderModal } = useDisclosure();
    const { isOpen: isViewDesignModalOpen, onOpen: onOpenViewDesignModal, onClose: onCloseViewDesignModal } = useDisclosure();
    const { isOpen: isDeleteDesignModalOpen, onOpen: onOpenDeleteDesignModal, onClose: onCloseDeleteDesignModal } = useDisclosure();
    const [editFormData, setEditFormData] = useState({ username: '', email: '', firstName: '', lastName: '', isAdmin: false, newPassword: '', confirmNewPassword: '' });
    const [showNewPasswordInModal, setShowNewPasswordInModal] = useState(false);
    const [showConfirmNewPasswordInModal, setShowConfirmNewPasswordInModal] = useState(false);
    const cancelRef = useRef();

    const dataFetchers = {
        1: useCallback(async () => { if (users.length > 0 || loadingUsers) return; setLoadingUsers(true); try { const { data } = await client.get('/admin/users', { headers: { Authorization: `Bearer ${token}` }}); setUsers(data); } catch (e) { setUsersError('Failed to fetch users'); } finally { setLoadingUsers(false); } }, [token, users.length, loadingUsers]),
        2: useCallback(async () => { if (orders.length > 0 || loadingOrders) return; setLoadingOrders(true); try { const { data } = await client.get('/admin/orders', { headers: { Authorization: `Bearer ${token}` }}); setOrders(data); } catch (e) { setOrdersError('Failed to fetch orders'); } finally { setLoadingOrders(false); } }, [token, orders.length, loadingOrders]),
        3: useCallback(async () => { if (designs.length > 0 || loadingDesigns) return; setLoadingDesigns(true); try { const { data } = await client.get('/admin/designs', { headers: { Authorization: `Bearer ${token}` }}); setDesigns(data); } catch (e) { setDesignsError('Failed to fetch designs'); } finally { setLoadingDesigns(false); } }, [token, designs.length, loadingDesigns]),
    };
    
    const handleTabsChange = (index) => { setTabIndex(index); const fetcher = dataFetchers[index]; if (fetcher) fetcher(); };
    const handleViewUser = (user) => { setSelectedUser(user); onViewUserModalOpen(); };
    const handleOpenEditUser = (user) => { setSelectedUser(user); setEditFormData({ username: user.username, email: user.email, firstName: user.firstName || '', lastName: user.lastName || '', isAdmin: user.isAdmin, newPassword: '', confirmNewPassword: '' }); onEditModalOpen(); };
    const handleEditFormChange = (e) => { const { name, value, type, checked } = e.target; setEditFormData(prev => ({ ...prev, [name]: type === 'checkbox' || type === 'switch' ? checked : value })); };
    const handleSaveChanges = async () => { if (!selectedUser) return; if (editFormData.newPassword && editFormData.newPassword !== editFormData.confirmNewPassword) { toast({ title: "Password Mismatch", status: "error" }); return; } const payload = { ...editFormData }; if (!payload.newPassword) delete payload.newPassword; delete payload.confirmNewPassword; try { const { data: updatedUser } = await client.put(`/admin/users/${selectedUser._id}`, payload, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "User Updated", status: "success" }); setUsers(prev => prev.map(u => u._id === updatedUser._id ? updatedUser : u)); onEditModalClose(); } catch (e) { toast({ title: "Update Failed", description: e.response?.data?.message, status: "error" }); } };
    const handleOpenDeleteUser = (user) => { setSelectedUser(user); onDeleteUserModalOpen(); };
    const confirmDeleteUser = async () => { if (!selectedUser) return; try { await client.delete(`/admin/users/${selectedUser._id}`, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "User Deleted", status: "success" }); setUsers(prev => prev.filter(u => u._id !== selectedUser._id)); onDeleteUserModalClose(); } catch (e) { toast({ title: "Delete Failed", description: e.response?.data?.message, status: "error" }); } };
    const handleOpenDeleteOrderDialog = (order) => { setOrderToDelete(order); onDeleteOrderModalOpen(); };
    const confirmDeleteOrder = async () => { if (!orderToDelete) return; try { await client.delete(`/admin/orders/${orderToDelete._id}`, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "Order Deleted", status: "success" }); setOrders(prev => prev.filter(o => o._id !== orderToDelete._id)); onDeleteOrderModalClose(); } catch (e) { toast({ title: "Delete Failed", description: e.response?.data?.message, status: "error" }); onDeleteOrderModalClose(); } };
    const handleViewOrder = async (orderId) => { setLoadingSelectedOrder(true); onOpenViewOrderModal(); try { const { data } = await client.get(`/admin/orders/${orderId}`, { headers: { Authorization: `Bearer ${token}` } }); setSelectedOrder(data); } catch (e) { toast({ title: "Error Fetching Order", status: "error" }); onCloseViewOrderModal(); } finally { setLoadingSelectedOrder(false); } };
    const handleStatusChange = async (orderId, newStatus) => { const originalOrders = [...orders]; setOrders(prevOrders => prevOrders.map(o => (o._id === orderId ? { ...o, orderStatus: newStatus } : o))); try { await client.put(`/admin/orders/${orderId}/status`, { status: newStatus }, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "Status Updated", status: "success", duration: 2000 }); } catch (e) { setOrders(originalOrders); toast({ title: "Update Failed", description: e.response?.data?.message, status: "error" }); } };
    const handleViewDesign = (design) => { setSelectedDesign(design); onOpenViewDesignModal(); };
    const handleOpenDeleteDesignDialog = (design) => { setDesignToDelete(design); onOpenDeleteDesignModal(); };
    const confirmDeleteDesign = async () => { if (!designToDelete) return; try { await client.delete(`/admin/designs/${designToDelete._id}`, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "Design Deleted", status: "success" }); setDesigns(prev => prev.filter(d => d._id !== designToDelete._id)); onCloseDeleteDesignModal(); } catch(e) { toast({ title: "Delete Failed", description: e.response?.data?.message, status: "error" }); } };

    const tabStyles = { bg: "brand.primaryLight", color: "whiteAlpha.700", border: "none", borderTopRadius: "lg", _selected: { color: "brand.textDark", bg: "brand.accentYellow", fontWeight: "bold" }, _hover: { bg: "brand.headerBg" } };
    
    const UsersPanel = () => ( <Box p={4}><Heading size="lg" mb={4} color="brand.textLight">User Management</Heading><TableContainer><Table variant="simple" size="sm" color="brand.textLight"><Thead><Tr><Th color="whiteAlpha.600">ID</Th><Th color="whiteAlpha.600">Username</Th><Th color="whiteAlpha.600">Email</Th><Th color="whiteAlpha.600">Name</Th><Th color="whiteAlpha.600">Admin</Th><Th color="whiteAlpha.600">Joined</Th><Th color="whiteAlpha.600">Actions</Th></Tr></Thead><Tbody>{users.map(user => (<Tr key={user._id} _hover={{bg:"brand.headerBg"}}><Td fontSize="xs">{user._id.substring(0,8)}</Td><Td>{user.username}</Td><Td>{user.email}</Td><Td>{`${user.firstName || ''} ${user.lastName || ''}`.trim()}</Td><Td><Tag colorScheme={user.isAdmin?'green':'gray'}>{user.isAdmin?'Yes':'No'}</Tag></Td><Td>{new Date(user.createdAt).toLocaleDateString()}</Td><Td><Tooltip label="View" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" onClick={() => handleViewUser(user)} icon={<Icon as={FaEye} />}/></Tooltip><Tooltip label="Edit" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" onClick={() => handleOpenEditUser(user)} icon={<Icon as={FaEdit} />}/></Tooltip><Tooltip label="Delete" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" colorScheme="red" onClick={() => handleOpenDeleteUser(user)} icon={<Icon as={FaTrashAlt} />}/></Tooltip></Td></Tr>))}</Tbody></Table></TableContainer></Box> );
    const OrdersPanel = () => { const getStatusColor = (status) => { if (status === 'Delivered') return 'green.600'; if (status === 'Shipped') return 'blue.600'; if (status === 'Cancelled') return 'red.600'; return 'purple.600'; }; return (<Box p={4}><Heading size="lg" mb={4} color="brand.textLight">Order Management</Heading><TableContainer><Table variant="simple" size="sm" color="brand.textLight"><Thead><Tr><Th color="whiteAlpha.600">ID</Th><Th color="whiteAlpha.600">User</Th><Th color="whiteAlpha.600">Date</Th><Th isNumeric color="whiteAlpha.600">Total</Th><Th color="whiteAlpha.600">Pay Status</Th><Th color="whiteAlpha.600">Order Status</Th><Th color="whiteAlpha.600">Items</Th><Th color="whiteAlpha.600">Actions</Th></Tr></Thead><Tbody>{orders.map(order => (<Tr key={order._id} _hover={{bg:"brand.headerBg"}}><Td fontSize="xs">{order._id.substring(0,8)}</Td><Td>{order.user?.email}</Td><Td>{new Date(order.createdAt).toLocaleDateString()}</Td><Td isNumeric>${(order.totalAmount/100).toFixed(2)}</Td><Td><Tag colorScheme={order.paymentStatus==='Succeeded'?'green':'orange'}>{order.paymentStatus}</Tag></Td><Td><ThemedSelect size="xs" value={order.orderStatus} onChange={e => handleStatusChange(order._id, e.target.value)} bg={getStatusColor(order.orderStatus)} borderRadius="md" maxW="120px" borderColor="transparent"><option style={{color:'black'}} value="Processing">Processing</option><option style={{color:'black'}} value="Shipped">Shipped</option><option style={{color:'black'}} value="Delivered">Delivered</option><option style={{color:'black'}} value="Cancelled">Cancelled</option></ThemedSelect></Td><Td>{order.orderItems.length}</Td><Td><Tooltip label="View" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" icon={<Icon as={FaEye} />} onClick={() => handleViewOrder(order._id)}/></Tooltip><Tooltip label="Delete" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" colorScheme="red" icon={<Icon as={FaTrashAlt} />} onClick={() => handleOpenDeleteOrderDialog(order)}/></Tooltip></Td></Tr>))}</Tbody></Table></TableContainer></Box>); };
    const DesignsPanel = () => ( <Box p={4}><Heading size="lg" mb={4} color="brand.textLight">Design Management</Heading><TableContainer><Table variant="simple" size="sm" color="brand.textLight"><Thead><Tr><Th color="whiteAlpha.600">Preview</Th><Th color="whiteAlpha.600">Prompt</Th><Th color="whiteAlpha.600">Creator</Th><Th color="whiteAlpha.600">Created</Th><Th color="whiteAlpha.600">Actions</Th></Tr></Thead><Tbody>{designs.map(design => (<Tr key={design._id} _hover={{bg:"brand.headerBg"}}><Td><Image src={design.imageDataUrl} boxSize="50px" objectFit="cover" borderRadius="md" bg="brand.primaryDark"/></Td><Td fontSize="xs">{design.prompt}</Td><Td>{design.user?.username}</Td><Td>{new Date(design.createdAt).toLocaleDateString()}</Td><Td><Tooltip label="View" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" icon={<Icon as={FaEye}/>} onClick={() => handleViewDesign(design)}/></Tooltip><Tooltip label="Delete" bg="brand.headerBg" color="white"><IconButton size="xs" variant="ghost" colorScheme="red" icon={<Icon as={FaTrashAlt}/>} onClick={() => handleOpenDeleteDesignDialog(design)}/></Tooltip></Td></Tr>))}</Tbody></Table></TableContainer></Box> );
    const InventoryPanel = () => (
        <Box p={{ base: 1, md: 4 }}>
            <Tabs variant='soft-rounded' colorScheme='yellow' isLazy>
                <TabList mb={6} flexWrap="wrap">
                    <Tab>Products</Tab>
                    <Tab>Product Types</Tab>
                    <Tab>Categories</Tab>
                </TabList>
                <TabPanels>
                    <TabPanel p={0}><ProductManager token={token} /></TabPanel>
                    <TabPanel p={0}><ProductTypeManager token={token} /></TabPanel>
                    <TabPanel p={0}><ProductCategoryManager token={token} /></TabPanel>
                </TabPanels>
            </Tabs>
        </Box>
    );

    return (
        <VStack w="100%" align="stretch" spacing={6}>
            <Heading as="h1" size="2xl" color="brand.textLight">Admin Console</Heading>
            <Box bg="brand.primaryDark" borderRadius="xl" borderWidth="1px" borderColor="whiteAlpha.200">
                <Tabs variant="unstyled" isLazy onChange={handleTabsChange} index={tabIndex}>
                    <TabList p={2} gap={2} borderBottomWidth="2px" borderBottomColor="whiteAlpha.300">
                        <Tab {...tabStyles}><Icon as={FaTachometerAlt} mr={2}/> Dashboard</Tab>
                        <Tab {...tabStyles}><Icon as={FaUsersCog} mr={2}/> Users</Tab>
                        <Tab {...tabStyles}><Icon as={FaBoxOpen} mr={2}/> Orders</Tab>
                        <Tab {...tabStyles}><Icon as={FaPalette} mr={2}/> Designs</Tab>
                        <Tab {...tabStyles}><Icon as={FaWarehouse} mr={2}/> Inventory</Tab>
                    </TabList>
                    <TabPanels bg="brand.primary" borderBottomRadius="xl">
                        <TabPanel p={0}><DashboardPanel token={token} onViewOrder={handleViewOrder} /></TabPanel>
                        <TabPanel>{loadingUsers ? <VStack p={10}><Spinner color="brand.accentYellow"/></VStack> : usersError ? <Alert status="error" bg="red.900" borderRadius="lg"><AlertIcon color="red.300"/>{usersError}</Alert> : <UsersPanel />}</TabPanel>
                        <TabPanel>{loadingOrders ? <VStack p={10}><Spinner color="brand.accentYellow"/></VStack> : ordersError ? <Alert status="error" bg="red.900" borderRadius="lg"><AlertIcon color="red.300"/>{ordersError}</Alert> : <OrdersPanel />}</TabPanel>
                        <TabPanel>{loadingDesigns ? <VStack p={10}><Spinner color="brand.accentYellow"/></VStack> : designsError ? <Alert status="error" bg="red.900" borderRadius="lg"><AlertIcon color="red.300"/>{designsError}</Alert> : <DesignsPanel />}</TabPanel>
                        <TabPanel><InventoryPanel /></TabPanel>
                    </TabPanels>
                </Tabs>
            </Box>
            {/* All modals would be defined here, styled for dark theme */}
        </VStack>
    );
};

export default AdminPage;
