import mongoose from 'mongoose';
import slugify from 'slugify';

const sizeVariantSchema = new mongoose.Schema({
  size: { type: String, required: true, trim: true },
  sku: { type: String, required: true, trim: true },
  inStock: { type: Boolean, default: true },
  priceModifier: { type: Number, default: 0 },
  podVariantId: { type: String, trim: true },
}, { _id: false });

const colorVariantSchema = new mongoose.Schema({
  colorName: { type: String, required: true, trim: true },
  colorHex: { type: String, trim: true },
  podProductId: { type: String, trim: true },
  isDefaultDisplay: { type: Boolean, default: false },
  imageSet: [{
    url: { type: String, required: true },
    altText: { type: String, default: '' },
    isPrimary: { type: Boolean, default: false }
  }],
  sizes: [sizeVariantSchema],
});

const productSchema = new mongoose.Schema(
  {
    name: { type: String, required: true, trim: true },
    slug: { type: String, unique: true, sparse: true },
    description: { type: String, required: true, trim: true },
    basePrice: { type: Number, required: true, min: 0 },
    tags: [{ type: String, trim: true }],
    isActive: { type: Boolean, default: true },
    variants: [colorVariantSchema],
  },
  {
    timestamps: true,
  }
);

productSchema.pre('save', function(next) {
  if (this.isNew || this.isModified('name') || !this.slug) {
    this.slug = slugify(this.name, { lower: true, strict: true });
  }
  next();
});

productSchema.index({ name: 'text', description: 'text', tags: 'text' });

const Product = mongoose.model('Product', productSchema);

export default Product;
import asyncHandler from 'express-async-handler'; // Keep this original import for asyncHandler
import mongoose from 'mongoose';
import User from '../models/User.js';
import Order from '../models/Order.js';
import Design from '../models/Design.js';
import Product from '../models/Product.js';

// REMOVED: The following lines were causing the "already declared" error:
// import { createRequire } from 'module';
// const require = createRequire(import.meta.url);
// const asyncHandler = require('express-async-handler');

// --- Dashboard ---
const getDashboardSummary = asyncHandler(async (req, res) => {
    const [totalSalesData, totalOrders, newUserCount, recentOrders] = await Promise.all([
        Order.aggregate([ { $match: { paymentStatus: 'Succeeded' } }, { $group: { _id: null, totalRevenue: { $sum: '$totalAmount' } } } ]),
        Order.countDocuments({}),
        User.countDocuments({ createdAt: { $gte: new Date(new Date().setDate(new Date().getDate() - 7)) } }),
        Order.find({}).sort({ createdAt: -1 }).limit(5).populate('user', 'username email')
    ]);
    const totalRevenue = totalSalesData.length > 0 ? totalSalesData[0].totalRevenue : 0;
    res.json({ totalRevenue, totalOrders, newUserCount, recentOrders });
});

// --- User Management ---
const getAllUsersAdmin = asyncHandler(async (req, res) => {
    const users = await User.find({}).select('-password');
    res.json(users || []);
});
const getUserByIdAdmin = asyncHandler(async (req, res) => {
    const user = await User.findById(req.params.id).select('-password');
    if (user) { res.json(user); } else { res.status(404); throw new Error('User not found'); }
});
const updateUserAdmin = asyncHandler(async (req, res) => {
    const user = await User.findById(req.params.id);
    if (user) { user.username = req.body.username || user.username; user.email = req.body.email || user.email; user.firstName = req.body.firstName !== undefined ? req.body.firstName : user.firstName; user.lastName = req.body.lastName !== undefined ? req.body.lastName : user.lastName; if (req.body.isAdmin !== undefined) { if (req.user._id.toString() === user._id.toString() && user.isAdmin && req.body.isAdmin === false) { res.status(400); throw new Error('Admins cannot remove their own admin status.'); } user.isAdmin = req.body.isAdmin; } const updatedUser = await user.save(); const userToSend = { ...updatedUser.toObject() }; delete userToSend.password; res.json(userToSend);
    } else { res.status(404); throw new Error('User not found'); }
});
const deleteUserAdmin = asyncHandler(async (req, res) => {
    if (req.user._id.toString() === req.params.id) { res.status(400); throw new Error('Admins cannot delete their own account.'); }
    const user = await User.findById(req.params.id);
    if (user) { await User.deleteOne({ _id: user._id }); res.json({ message: 'User removed successfully' }); } else { res.status(404); throw new Error('User not found'); }
});

// --- Order Management ---
const getAllOrdersAdmin = asyncHandler(async (req, res) => {
    const orders = await Order.find({}).populate('user', 'id username email').sort({ createdAt: -1 });
    res.json(orders || []);
});
const deleteOrderAdmin = asyncHandler(async (req, res) => {
    const order = await Order.findById(req.params.id);
    if (order) { await Order.deleteOne({ _id: req.params.id }); res.json({ message: 'Order removed successfully' }); } else { res.status(404); throw new Error('Order not found'); }
});
const getOrderByIdAdmin = asyncHandler(async (req, res) => {
    const order = await Order.findById(req.params.id).populate('user', 'username email firstName lastName').populate('orderItems.designId', 'imageDataUrl prompt');
    if (order) { res.json(order); } else { res.status(404); throw new Error('Order not found'); }
});
const updateOrderStatusAdmin = asyncHandler(async (req, res) => {
    const { status } = req.body;
    const allowedStatuses = ['Processing', 'Shipped', 'Delivered', 'Cancelled'];
    if (!status || !allowedStatuses.includes(status)) { res.status(400); throw new Error(`Invalid status.`); }
    const order = await Order.findById(req.params.id);
    if (order) { order.orderStatus = status; const updatedOrder = await order.save(); res.json(updatedOrder); } else { res.status(404); throw new Error('Order not found'); }
});

// --- Design Management ---
const getAllDesignsAdmin = asyncHandler(async (req, res) => {
    const designs = await Design.find({}).populate('user', 'id username email').sort({ createdAt: -1 });
    res.json(designs || []);
});
const deleteDesignAdmin = asyncHandler(async (req, res) => {
    const design = await Design.findById(req.params.id);
    if (design) { await Design.deleteOne({ _id: design._id }); res.json({ message: 'Design removed successfully' }); } 
    else { res.status(404); throw new Error('Design not found'); }
});

// --- Product Management ---
const createProductAdmin = asyncHandler(async (req, res) => {
    const { name, description, basePrice, tags, isActive, variants } = req.body;
    
    if (variants) {
        if (!Array.isArray(variants)) { res.status(400); throw new Error('Variants must be an array.'); }
        if (variants.length > 0 && variants.filter(v => v.isDefaultDisplay).length !== 1) {
            res.status(400); throw new Error('Exactly one variant must be marked as the default display.');
        }
    }
    const product = new Product({ name, description, basePrice, tags, isActive, variants });
    const createdProduct = await product.save();
    res.status(201).json(createdProduct);
});

const getProductsAdmin = asyncHandler(async (req, res) => {
    const products = await Product.find({}).select('-variants').sort({ name: 1 }).lean();
    res.json(products);
});

const getProductByIdAdmin = asyncHandler(async (req, res) => {
    const product = await Product.findById(req.params.id); 
    if (product) { res.json(product); } else { res.status(404); throw new Error('Product not found'); }
});

const updateProductAdmin = asyncHandler(async (req, res) => {
    const { name, description, basePrice, tags, isActive, variants } = req.body;
    const product = await Product.findById(req.params.id);
    if (product) {
        if (variants) {
            if (!Array.isArray(variants)) { res.status(400); throw new Error('Variants must be an array.'); }
            if (variants.length > 0 && variants.filter(v => v.isDefaultDisplay).length !== 1) {
                res.status(400); throw new Error('Exactly one variant must be marked as the default display.');
            }
        }
        product.name = name;
        product.description = description;
        product.basePrice = basePrice;
        product.tags = tags;
        product.isActive = isActive;
        product.variants = variants;
        const updatedProduct = await product.save();
        res.json(updatedProduct);
    } else {
        res.status(404); throw new Error('Product not found');
    }
});

const deleteProductAdmin = asyncHandler(async (req, res) => {
    const product = await Product.findById(req.params.id);
    if (product) {
        await Product.deleteOne({ _id: product._id });
        res.json({ message: 'Product removed' });
    } else {
        res.status(404); throw new Error('Product not found');
    }
});

export {
    getDashboardSummary, getAllUsersAdmin, getUserByIdAdmin, updateUserAdmin, deleteUserAdmin,
    getAllOrdersAdmin, deleteOrderAdmin, getOrderByIdAdmin, updateOrderStatusAdmin,
    getAllDesignsAdmin, deleteDesignAdmin,
    createProductAdmin, getProductsAdmin, getProductByIdAdmin, updateProductAdmin, deleteProductAdmin
};
// backend/controllers/authController.js
import asyncHandler from 'express-async-handler';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
// import sgMail from '@sendgrid/mail'; // Original line - REMOVED
import { createRequire } from 'module'; // NEW: Import createRequire
const require = createRequire(import.meta.url); // NEW: Create a require function for this module
const sgMail = require('@sendgrid/mail'); // NEW: Use require for sendgrid/mail

import User from '../models/User.js';
import 'dotenv/config';

import { validationResult } from 'express-validator';

if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
} else {
  console.error('[Auth Cfg] WARNING: SENDGRID_API_KEY environment variable is not set! Email sending will fail.');
}

const generateToken = (id) => {
  return jwt.sign({ user: { id } }, process.env.JWT_SECRET, {
    expiresIn: '1h',
  });
};

export const registerUser = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) { return res.status(400).json({ errors: errors.array() }); }

  const { username, email, password, firstName, lastName } = req.body;
  const userExistsByEmail = await User.findOne({ email: email.toLowerCase() });
  if (userExistsByEmail) { res.status(400); throw new Error('User with this email already exists'); }
  const userExistsByUsername = await User.findOne({ username });
  if (userExistsByUsername) { res.status(400); throw new Error('Username already taken'); }

  const user = await User.create({ username, email: email.toLowerCase(), password, firstName: firstName || '', lastName: lastName || '' });
  if (user) {
    const token = generateToken(user._id);
    res.cookie('token', token, { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax', maxAge: 3600 * 1000 });
    res.status(201).json({ _id: user._id, username: user.username, email: user.email, firstName: user.firstName, lastName: user.lastName, isAdmin: user.isAdmin, token: token });
  } else {
    res.status(400); throw new Error('Invalid user data during registration');
  }
});

export const loginUser = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) { return res.status(400).json({ errors: errors.array() }); }

  const { email, password } = req.body;
  const user = await User.findOne({ email: email.toLowerCase() }).select('+password');
  if (user && (await user.matchPassword(password))) {
    const token = generateToken(user._id);
    res.cookie('token', token, { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax', maxAge: 3600 * 1000 });
    res.json({ _id: user._id, username: user.username, email: user.email, firstName: user.firstName, lastName: user.lastName, isAdmin: user.isAdmin, shippingAddress: user.shippingAddress, billingAddress: user.billingAddress, token: token });
  } else {
    res.status(401); throw new Error('Invalid email or password');
  }
});

export const getUserProfile = asyncHandler(async (req, res) => {
  const user = await User.findById(req.user.id).select('-password');
  if (user) {
    res.json({ _id: user._id, username: user.username, email: user.email, firstName: user.firstName, lastName: user.lastName, isAdmin: user.isAdmin, shippingAddress: user.shippingAddress, billingAddress: user.billingAddress, lastContestSubmissionMonth: user.lastContestSubmissionMonth, monthlyVoteRecord: user.monthlyVoteRecord });
  } else {
    res.status(404); throw new Error('User not found for profile');
  }
});

export const updateUserProfile = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) { return res.status(400).json({ errors: errors.array() }); }

  const user = await User.findById(req.user.id);
  if (user) {
    user.username = req.body.username || user.username;
    if (req.body.email && req.body.email.toLowerCase() !== user.email) {
        const existingUser = await User.findOne({ email: req.body.email.toLowerCase() });
        if (existingUser && existingUser._id.toString() !== user._id.toString()) {
            res.status(400); throw new Error('Email already in use.');
        }
        user.email = req.body.email.toLowerCase();
    }
    user.firstName = req.body.firstName !== undefined ? req.body.firstName : user.firstName;
    user.lastName = req.body.lastName !== undefined ? req.body.lastName : user.lastName;
    const updateAddress = (currentAddressDoc, newAddressData) => {
      if (!newAddressData && newAddressData !== null) return currentAddressDoc;
      if (newAddressData === null) return undefined;
      const addressToUpdate = currentAddressDoc || {};
      Object.keys(newAddressData).forEach(key => { if (newAddressData[key] !== undefined) addressToUpdate[key] = newAddressData[key]; });
      return addressToUpdate;
    };
    if (req.body.shippingAddress !== undefined) user.shippingAddress = updateAddress(user.shippingAddress, req.body.shippingAddress);
    if (req.body.billingAddress !== undefined) user.billingAddress = updateAddress(user.billingAddress, req.body.billingAddress);
    const updatedUser = await user.save();
    res.json({ _id: updatedUser._id, username: updatedUser.username, email: updatedUser.email, firstName: updatedUser.firstName, lastName: updatedUser.lastName, isAdmin: updatedUser.isAdmin, shippingAddress: updatedUser.shippingAddress, billingAddress: updatedUser.billingAddress });
  } else {
    res.status(404); throw new Error('User not found for profile update');
  }
});

export const changePassword = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) { return res.status(400).json({ errors: errors.array() }); }

  const { currentPassword, newPassword } = req.body;
  const user = await User.findById(req.user.id).select('+password');
  if (!user) { res.status(404); throw new Error('User not found.'); }
  const isMatch = await user.matchPassword(currentPassword);
  if (!isMatch) { res.status(401); throw new Error('Incorrect current password.'); }
  user.password = newPassword;
  await user.save();
  res.status(200).json({ message: 'Password changed successfully.' });
});

export const logoutUser = asyncHandler(async (req, res) => {
  res.cookie('token', '', { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax', expires: new Date(0) });
  res.status(200).json({ message: 'Logged out successfully' });
});

export const requestPasswordReset = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) { return res.status(400).json({ errors: errors.array() }); }

  const { email } = req.body;
  const user = await User.findOne({ email: email.toLowerCase() });
  if (!user) {
    return res.status(200).json({ message: 'If your email is registered, you will receive a password reset link shortly.' });
  }
  const resetToken = crypto.randomBytes(32).toString('hex');
  const hashedToken = crypto.createHash('sha256').update(resetToken).digest('hex');
  user.passwordResetToken = hashedToken;
  user.passwordResetExpires = Date.now() + 3600000;
  try {
    await user.save({ validateBeforeSave: false });
    if (!process.env.SENDGRID_API_KEY || !process.env.SENDGRID_FROM_EMAIL || !process.env.FRONTEND_URL) { throw new Error("Server configuration error for sending email."); }
    const resetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;
    const messageBody = `<p>You are receiving this email because you (or someone else) have requested the reset of the password for your account.</p><p>Please click on the following link, or paste this into your browser to complete the process within one hour of receiving it:</p><p><a href="${resetUrl}">${resetUrl}</a></p><p>If you did not request this, please ignore this email and your password will remain unchanged.</p>`;
    const msg = { to: user.email, from: { email: process.env.SENDGRID_FROM_EMAIL, name: 'TeesFromThePast Support' }, subject: 'Password Reset Request', html: messageBody };
    await sgMail.send(msg);
    res.status(200).json({ message: 'If your email is registered, you will receive a password reset link shortly.' });
  } catch (error) {
    console.error('[Auth Ctrl] Error during SendGrid password reset process:', error);
    user.passwordResetToken = undefined; user.passwordResetExpires = undefined;
    try { await user.save({ validateBeforeSave: false }); }
    catch (saveError) { console.error(`[Auth Ctrl] CRITICAL: Failed to clear token for ${user.email}:`, saveError); }
    res.status(500).json({ message: 'There was an issue processing your request. Please try again later.' });
  }
});

export const resetPassword = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) { return res.status(400).json({ errors: errors.array() }); }
  
  const { token, password } = req.body;
  const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
  const user = await User.findOne({ passwordResetToken: hashedToken, passwordResetExpires: { $gt: Date.now() } }).select('+passwordResetToken +passwordResetExpires');
  if (!user) { res.status(400); throw new Error('Password reset token is invalid or has expired.'); }
  user.password = password;
  user.passwordResetToken = undefined;
  user.passwordResetExpires = undefined;
  await user.save();
  res.status(200).json({ message: 'Password has been reset successfully. You can now log in with your new password.' });
});
import asyncHandler from 'express-async-handler';
// import sgMail from '@sendgrid/mail'; // Original line - REMOVED
import { createRequire } from 'module'; // NEW: Import createRequire
const require = createRequire(import.meta.url); // NEW: Create a require function for this module
const sgMail = require('@sendgrid/mail'); // NEW: Use require for sendgrid/mail

import 'dotenv/config';
import { validationResult } from 'express-validator';

if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
} else {
  console.error('[Form Cfg] WARNING: SENDGRID_API_KEY environment variable is not set! Email sending will fail.');
}

export const submitContactForm = asyncHandler(async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { name, email, subject, message } = req.body;

  if (!process.env.SENDGRID_API_KEY || !process.env.SENDGRID_FROM_EMAIL) {
    console.error('[Form Cfg] Server configuration error: SendGrid API Key or From Email not set.');
    res.status(500);
    throw new Error('Server configuration error for sending email.');
  }

  const msgToAdmin = {
    to: process.env.SENDGRID_FROM_EMAIL, // Send to your admin email
    from: {
      email: process.env.SENDGRID_FROM_EMAIL, // Your verified SendGrid sender
      name: 'Tees From The Past - Contact Form',
    },
    replyTo: email, // Set the user's email as reply-to
    subject: `Contact Form Submission: ${subject}`,
    html: `
      <p><strong>Name:</strong> ${name}</p>
      <p><strong>Email:</strong> ${email}</p>
      <p><strong>Subject:</strong> ${subject}</p>
      <p><strong>Message:</strong></p>
      <p>${message}</p>
    `,
  };

  const msgToUser = {
    to: email, // Send a confirmation to the user
    from: {
      email: process.env.SENDGRID_FROM_EMAIL, // Your verified SendGrid sender
      name: 'Tees From The Past',
    },
    subject: 'Thank You for Your Inquiry - Tees From The Past',
    html: `
      <p>Dear ${name},</p>
      <p>Thank you for reaching out to us. We have received your message regarding "${subject}" and will get back to you as soon as possible.</p>
      <p>Here is a copy of your message for your reference:</p>
      <hr/>
      <p><strong>Subject:</strong> ${subject}</p>
      <p><strong>Message:</strong></p>
      <p>${message}</p>
      <hr/>
      <p>Best regards,</p>
      <p>The Tees From The Past Team</p>
    `,
  };

  try {
    await sgMail.send(msgToAdmin);
    await sgMail.send(msgToUser);
    res.status(200).json({ message: 'Message sent successfully!' });
  } catch (error) {
    console.error('[Form Ctrl] SendGrid Error:', error.response?.body || error.message);
    res.status(500);
    throw new Error('Failed to send message. Please try again later.');
  }
});
import asyncHandler from 'express-async-handler';
import Product from '../models/Product.js';
import mongoose from 'mongoose';

// NEW FUNCTION: Gets a simple list of all active products
const getAllActiveProducts = asyncHandler(async (req, res) => {
    const products = await Product.find({ isActive: true, 'variants.0': { $exists: true } })
        .select('name variants description basePrice slug') // Removed category
        .lean(); // Removed .populate('category', 'name')
    res.json(products);
});

const getProductBySlug = asyncHandler(async (req, res) => {
    const product = await Product.findOne({ slug: req.params.slug, isActive: true }).lean();
    if (!product) {
        res.status(404);
        throw new Error('Product not found');
    }
   
    product.variants.forEach(colorVariant => {
        if (colorVariant.sizes && Array.isArray(colorVariant.sizes)) {
            colorVariant.sizes = colorVariant.sizes.filter(size => size.inStock);
        }
    });
    product.variants = product.variants.filter(colorVariant => colorVariant.sizes && colorVariant.sizes.length > 0);
   
    res.json(product);
});

export {
  getAllActiveProducts,
  getProductBySlug,
};
// backend/routes/formRoutes.js
import express from 'express';
// Corrected import: Changed handleContactForm to submitContactForm
import { submitContactForm } from '../controllers/formController.js'; 

const router = express.Router();

// @desc    Handle contact form submission
// @route   POST /api/forms/contact
// @access  Public
// Corrected usage: Changed handleContactForm to submitContactForm
router.post('/contact', submitContactForm); 

export default router;
import express from 'express';
import {
    getAllActiveProducts,
    getProductBySlug,
} from '../controllers/storefrontProductController.js';

const router = express.Router();

// This route gets a flat list of all active products
router.get('/products', getAllActiveProducts);

// This route gets a single product by its unique slug for the detail page
router.get('/products/slug/:slug', getProductBySlug);

export default router;
import express from 'express';
import mongoose from 'mongoose';
import 'dotenv/config';
import cookieParser from 'cookie-parser';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';

// Route Imports
import authRoutes from './routes/auth.js';
import generateImageRoutes from './routes/generateImage.js';
import stripeWebhookRoutes from './routes/stripeWebhook.js';
import checkoutRoutes from './routes/checkout.js';
import designRoutes from './routes/designs.js';
import contestRoutes from './routes/contest.js';
import orderRoutes from './routes/orders.js';
import formRoutes from './routes/formRoutes.js';
import adminUserRoutes from './routes/adminUserRoutes.js';
import adminOrderRoutes from './routes/adminOrderRoutes.js';
import adminDesignRoutes from './routes/adminDesignRoutes.js';
// REMOVED: adminProductCategoryRoutes is no longer needed
// REMOVED: adminProductTypeRoutes is no longer needed
import adminProductRoutes from './routes/adminProductRoutes.js';
import storefrontProductRoutes from './routes/storefrontProductRoutes.js';

const app = express();

// --- Middleware Configuration ---

// Apply essential security headers
app.use(helmet());

// CORS configuration to allow your frontend to connect
const allowedOrigins = [
  'https://teesfromthepast.vercel.app',
  'http://localhost:5173'
];
const corsOptions = {
  origin: function (origin, callback) {
    if (!origin || allowedOrigins.indexOf(origin) !== -1 || origin.endsWith('-delv3chios-projects.vercel.app')) {
      callback(null, true);
    } else {
      console.warn(`[CORS] Blocked origin: ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
};
app.use(cors(corsOptions));

// Cookie parser to read cookies
app.use(cookieParser());

// Special route for Stripe webhook before body parsing
app.use('/api/stripe', stripeWebhookRoutes);

// Body parsers with increased limits
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));

// Rate limiter to protect API routes from spam/abuse
const limiter = rateLimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	max: 100, 
	standardHeaders: true,
	legacyHeaders: false,
  message: 'Too many requests from this IP, please try again after 15 minutes',
});
app.use('/api', limiter);

// --- Route Definitions ---

app.get('/', (req, res) => {
  res.send('Tees From The Past Backend API');
});

app.get('/health', (req, res) => {
  res.status(200).json({ status: 'OK', message: 'Backend is healthy!' });
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api', generateImageRoutes);
app.use('/api/checkout', checkoutRoutes);
app.use('/api/mydesigns', designRoutes);
app.use('/api/contest', contestRoutes);
app.use('/api/orders', orderRoutes);
app.use('/api/forms', formRoutes);
app.use('/api/storefront', storefrontProductRoutes);
app.use('/api/admin/users', adminUserRoutes);
app.use('/api/admin/orders', adminOrderRoutes);
app.use('/api/admin/designs', adminDesignRoutes);
// REMOVED: app.use('/api/admin/product-categories', adminProductCategoryRoutes);
// REMOVED: The route for product-types is no longer needed
app.use('/api/admin/products', adminProductRoutes);

// --- Global Error Handler ---
app.use((err, req, res, next) => {
  console.error('[Backend Log] Global Server Error:', err.message, err.stack ? `\nStack: ${err.stack}` : '');
  const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  res.status(statusCode);
  res.json({
    message: err.message,
    stack: process.env.NODE_ENV === 'production' ? '🥞' : err.stack,
  });
});

export default app;
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "start": "node index.js",
    "server": "nodemon index.js",
    "test": "cross-env NODE_ENV=test jest --detectOpenHandles --forceExit --runInBand",
    "data:import": "node setup.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@stripe/stripe-js": "^4.0.0",
    "axios": "^1.7.2",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-async-handler": "^1.2.0",
    "express-rate-limit": "^7.3.0",
    "express-validator": "^7.0.1",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.4.1",
    "nodemailer": "^6.9.13",
    "slugify": "^1.6.6",
    "stripe": "^15.9.0"
  },
  "devDependencies": {
    "cross-env": "^7.0.3",
    "jest": "^29.7.0",
    "mongodb-memory-server": "^9.3.0",
    "nodemon": "^3.1.2",
    "supertest": "^7.0.0"
  },
  "jest": {
    "testEnvironment": "node"
  }
}
// frontend/src/components/admin/InventoryPanel.jsx
import React from 'react';
import {
  Box,
  Heading,
  Tabs,
  TabList,
  Tab,
  TabPanels,
  TabPanel,
  Icon,
} from '@chakra-ui/react';
import { FaTshirt } from 'react-icons/fa'; // Removed FaTags as categories are gone

import ProductManager from './ProductManager.jsx';

const InventoryPanel = () => {
  return (
    <Box w="100%">
      <Heading size="lg" mb={6} color="brand.textDark" textAlign={{ base: "center", md: "left" }}>
        Inventory & Product Management
      </Heading>
      <Tabs variant="enclosed-colored" colorScheme="gray" isLazy>
        <TabList flexWrap="wrap">
          {/* Removed Categories Tab */}
          <Tab _selected={{ color: 'brand.textDark', bg: 'gray.100', fontWeight: 'bold' }} m={1}>
            <Icon as={FaTshirt} mr={2} /> Products
          </Tab>
        </TabList>
        <TabPanels>
          {/* Removed Categories TabPanel */}
          <TabPanel px={0} py={4}>
            <ProductManager />
          </TabPanel>
        </TabPanels>
      </Tabs>
    </Box>
  );
};

export default InventoryPanel;
import React, { useState, useEffect, useCallback } from 'react';
import {
  Box, Heading, Button, Table, Thead, Tbody, Tr, Th, Td, TableContainer,
  Spinner, Alert, AlertIcon, VStack, Text, useToast, IconButton as ChakraIconButton,
  Modal, ModalOverlay, ModalContent, ModalHeader, ModalFooter, ModalBody, ModalCloseButton,
  useDisclosure, FormControl, FormLabel, Input, Select, Switch, HStack, Tooltip, Icon,
  Tag, SimpleGrid, Textarea, NumberInput, NumberInputField, NumberInputStepper,
  NumberIncrementStepper, NumberDecrementStepper, Divider, CloseButton,

  Image, Accordion, AccordionItem, AccordionButton, AccordionPanel, AccordionIcon,
  Wrap, WrapItem, Radio, RadioGroup, Stack, Flex
} from '@chakra-ui/react';
import { FaPlus, FaEdit, FaTrashAlt, FaImage, FaStar } from 'react-icons/fa';
import { client } from '../../api/client';
import { useAuth } from '../../context/AuthProvider';

const SIZES = ["XS", "S", "M", "L", "XL", "XXL", "One Size", "6M", "12M", "18M", "24M"];
const CORE_COLORS = [ { name: "Black", hex: "#000000" }, { name: "White", hex: "#FFFFFF" }, { name: "Navy Blue", hex: "#000080" }, { name: "Heather Grey", hex: "#B2BEB5" }, { name: "Cream / Natural", hex: "#FFFDD0" }, { name: "Mustard Yellow", hex: "#FFDB58" }, { name: "Olive Green", hex: "#556B2F" }, { name: "Maroon", hex: "#800000" }, { name: "Burnt Orange", hex: "#CC5500" }, { name: "Heather Forest", hex: "#228B22" }, { name: "Royal Blue", hex: "#4169E1" }, { name: "Charcoal", hex: "#36454F" }, { name: "Sand", hex: "#C2B280" }, { name: "Light Blue", hex: "#ADD8E6" }, { name: "Cardinal Red", hex: "#C41E3A" }, { name: "Teal", hex: "#008080" } ];

const initialColorVariantState = {
  colorName: '',
  colorHex: '',
  podProductId: '',
  isDefaultDisplay: false,
  imageSet: [{ url: '', isPrimary: true }],
};

const ProductManager = () => {
  const { token } = useAuth();
  const toast = useToast();
  const [products, setProducts] = useState([]);
  // Removed categories state: const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [isModalLoading, setIsModalLoading] = useState(false);
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  // Removed category from formData:
  const [formData, setFormData] = useState({ name: '', description: '', basePrice: 0, tags: '', isActive: true, variants: [] });
  const [newColorData, setNewColorData] = useState({ colorName: '', colorHex: '', podProductId: '' });
  const { isOpen, onOpen, onClose } = useDisclosure();
  const { isOpen: isDeleteOpen, onOpen: onDeleteOpen, onClose: onDeleteClose } = useDisclosure();

  const fetchProducts = useCallback(async () => {
    setLoading(true); setError('');
    try {
      const { data } = await client.get('/admin/products', { headers: { Authorization: `Bearer ${token}` } });
      setProducts(data);
    } catch (err) {
      setError(err.response?.data?.message || 'Failed to fetch products.');
    } finally {
      setLoading(false);
    }
  }, [token]);

  // Removed fetchCategories useEffect and function call
  useEffect(() => { if (token) { fetchProducts(); } }, [token, fetchProducts]);

  const handleOpenModal = async (product = null) => {
    onOpen(); setIsModalLoading(true);
    try {
      // Removed activeCategories filter
      setNewColorData({ colorName: '', colorHex: '', podProductId: '' });
      if (product) {
        const { data: fullProductData } = await client.get(`/admin/products/${product._id}`, { headers: { Authorization: `Bearer ${token}` }});
        setIsEditing(true);
        setSelectedProduct(fullProductData);
        setFormData({
          name: fullProductData.name, description: fullProductData.description || '', // Removed category
          basePrice: fullProductData.basePrice || 0, tags: Array.isArray(fullProductData.tags) ? fullProductData.tags.join(', ') : '',
          isActive: fullProductData.isActive,
          variants: (fullProductData.variants || []).map(v => ({...v, imageSet: v.imageSet && v.imageSet.length > 0 ? v.imageSet : [{ url: '', isPrimary: true }], sizes: v.sizes || [] }))
        });
      } else {
        setIsEditing(false); setSelectedProduct(null);
        // Removed category from initial formData
        setFormData({ name: '', description: '', basePrice: 0, tags: '', isActive: true, variants: [] });
      }
    } catch (err) { toast({ title: "Error", description: "Could not load data for the form.", status: "error" }); onClose(); } 
    finally { setIsModalLoading(false); }
  };

  const handleFormChange = (e) => { const { name, value, type, checked } = e.target; setFormData(prev => ({ ...prev, [name]: type === 'checkbox' || type === 'switch' ? checked : value })); };
  const handleBasePriceChange = (valStr, valNum) => { setFormData(prev => ({ ...prev, basePrice: valNum || 0 })); };
  const handleNewColorFormChange = (e) => { const { name, value } = e.target; if (name === "colorName") { const sel = CORE_COLORS.find(c => c.name === value); setNewColorData(prev => ({ ...prev, colorName: value, colorHex: sel ? sel.hex : '' })); } else { setNewColorData(prev => ({ ...prev, [name]: value })); } };
 
  const handleAddColorVariant = () => {
    if (!newColorData.colorName) { toast({ title: "Color Name Required", status: "warning" }); return; }
    if (formData.variants.some(v => v.colorName === newColorData.colorName)) { toast({ title: "Duplicate Color", status: "warning" }); return; }
    const newVariant = {
      ...initialColorVariantState, ...newColorData,
      sizes: SIZES.map(s => ({ size: s, sku: `${(formData.name || 'PROD').substring(0, 5).toUpperCase().replace(/\s+/g, '')}-${newColorData.colorName.toUpperCase().replace(/[\s/]+/g, '')}-${s}`, inStock: true, priceModifier: 0 }))
    };
    if (formData.variants.length === 0) { newVariant.isDefaultDisplay = true; }
    setFormData(prev => ({ ...prev, variants: [...prev.variants, newVariant] }));
    setNewColorData({ colorName: '', colorHex: '', podProductId: '' });
  };
 
  const handleRemoveColorVariant = (colorIndex) => { const newVariants = [...formData.variants]; newVariants.splice(colorIndex, 1); if (newVariants.length > 0 && !newVariants.some(v => v.isDefaultDisplay)) { newVariants[0].isDefaultDisplay = true; } setFormData(prev => ({ ...prev, variants: newVariants })); };
  const handleSizeDetailChange = (colorIdx, sizeIdx, field, value) => { const newV = [...formData.variants]; newV[colorIdx].sizes[sizeIdx][field] = value; setFormData(prev => ({ ...prev, variants: newV })); };
  const handleImageSetUrlChange = (colorIndex, imageIndex, url) => { const newVariants = [...formData.variants]; newVariants[colorIndex].imageSet[imageIndex].url = url; setFormData(prev => ({ ...prev, variants: newVariants })); };
  const addImageToSet = (colorIndex) => { const newVariants = [...formData.variants]; newVariants[colorIndex].imageSet.push({ url: '', isPrimary: false }); setFormData(prev => ({ ...prev, variants: newVariants })); };
  const removeImageFromSet = (colorIndex, imageIndex) => { const newVariants = [...formData.variants]; if(newVariants[colorIndex].imageSet.length > 1) { newVariants[colorIndex].imageSet.splice(imageIndex, 1); if (!newVariants[colorIndex].imageSet.some(img => img.isPrimary)) { newVariants[colorIndex].imageSet[0].isPrimary = true; } setFormData(prev => ({ ...prev, variants: newVariants })); } };
  const setPrimaryImage = (colorIndex, imageIndex) => { const newVariants = [...formData.variants]; newVariants[colorIndex].imageSet.forEach((img, idx) => { img.isPrimary = idx === imageIndex; }); setFormData(prev => ({ ...prev, variants: newVariants })); };
  const setDefaultVariant = (colorIndexToSet) => { const newVariants = formData.variants.map((v, index) => ({ ...v, isDefaultDisplay: index === colorIndexToSet })); setFormData(prev => ({ ...prev, variants: newVariants })); };
 
  const handleSubmit = async () => {
    // Removed category validation
    if (!formData.name.trim()) { toast({ title: "Validation Error", description: "Product Name is required.", status: "error" }); return; }
    for (const variant of formData.variants) { for (const image of variant.imageSet) { if (!image.url || image.url.trim() === '') { toast({ title: "Image URL Missing", description: `Please provide a URL for all images in the "${variant.colorName}" variant gallery.`, status: "error" }); return; } } }
    if (formData.variants.length > 0 && !formData.variants.some(v => v.isDefaultDisplay)) { formData.variants[0].isDefaultDisplay = true; }
    for (const variant of formData.variants) { if (variant.imageSet && !variant.imageSet.some(img => img.isPrimary)) { if(variant.imageSet.length > 0) variant.imageSet[0].isPrimary = true; } for (const size of variant.sizes) { if (size.inStock && !size.sku) { toast({ title: "Validation Error", description: `SKU missing for in-stock size ${size.size} in ${variant.colorName}.`, status: "error" }); return; } } }
    const method = isEditing ? 'put' : 'post';
    const url = isEditing ? `/admin/products/${selectedProduct._id}` : '/admin/products';
    // Removed category from payload
    const payload = { ...formData, tags: (formData.tags || '').split(',').map(tag => tag.trim()).filter(Boolean) };
    try { await client[method](url, payload, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: `Product ${isEditing ? 'Updated' : 'Created'}`, status: "success" }); fetchProducts(); onClose(); } 
    catch (err) { toast({ title: `Error Saving Product`, description: err.response?.data?.message, status: "error" }); }
  };
 
  const handleOpenDeleteDialog = (product) => { setSelectedProduct(product); onDeleteOpen(); };
  const handleDelete = async () => { if (!selectedProduct) return; try { await client.delete(`/admin/products/${selectedProduct._id}`, { headers: { Authorization: `Bearer ${token}` } }); toast({ title: "Product Deleted", status: "success" }); fetchProducts(); onDeleteClose(); } catch (err) { toast({ title: "Delete Failed", description: err.response?.data?.message, status: "error" }); onDeleteClose(); } };

  if (loading) return <VStack justifyContent="center" minH="200px"><Spinner size="xl" /></VStack>;
  if (error) return <Alert status="error"><AlertIcon />{error}</Alert>;

  return (
    <Box p={{ base: 2, md: 4 }}>
      <HStack justifyContent="space-between" mb={6}>
        <Heading size="md">Manage Products</Heading>
        <Button leftIcon={<Icon as={FaPlus} />} colorScheme="brandAccentOrange" onClick={() => handleOpenModal()}>Add New Product</Button>
      </HStack>
      <TableContainer>
        <Table variant="simple" size="sm">
          <Thead><Tr><Th>Name</Th><Th>Base Price</Th><Th>Variants</Th><Th>Status</Th><Th>Actions</Th></Tr></Thead> {/* Removed Category Th */}
          <Tbody>{products.map((p) => (<Tr key={p._id}><Td fontWeight="medium">{p.name}</Td><Td>${p.basePrice?.toFixed(2)}</Td><Td>{p.variantCount !== undefined ? p.variantCount : '-'}</Td><Td><Tag colorScheme={p.isActive ? 'green' : 'red'}>{p.isActive ? 'Active' : 'Inactive'}</Tag></Td><Td><Tooltip label="Edit"><ChakraIconButton icon={<Icon as={FaEdit}/>} size="xs" variant="ghost" onClick={() => handleOpenModal(p)}/></Tooltip><Tooltip label="Delete"><ChakraIconButton icon={<Icon as={FaTrashAlt}/>} size="xs" variant="ghost" colorScheme="red" onClick={() => handleOpenDeleteDialog(p)}/></Tooltip></Td></Tr>))}</Tbody> {/* Removed Category Td: categories.find(pt => pt._id === p.category)?.name || 'N/A' */}
        </Table>
      </TableContainer>
     
      <Modal isOpen={isOpen} onClose={onClose} size="6xl" scrollBehavior="inside">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>{isEditing ? 'Edit' : 'Add New'} Product</ModalHeader>
          <ModalCloseButton />
          <ModalBody pb={6}>
            {isModalLoading ? <VStack justifyContent="center" minH="400px"><Spinner size="xl" /></VStack> : (
            <VStack spacing={6} align="stretch">
                <Box p={4} borderWidth="1px" borderRadius="md"><Heading size="sm" mb={4}>Product Details</Heading><SimpleGrid columns={{base: 1, md: 2}} spacing={4}><FormControl isRequired><FormLabel>Name</FormLabel><Input name="name" value={formData.name} onChange={handleFormChange}/></FormControl><FormControl isRequired><FormLabel>Base Price ($)</FormLabel><NumberInput value={formData.basePrice} onChange={handleBasePriceChange} min={0} precision={2}><NumberInputField/><NumberInputStepper><NumberIncrementStepper/><NumberDecrementStepper/></NumberInputStepper></NumberInput></FormControl><FormControl><FormLabel>Tags (comma-separated)</FormLabel><Input name="tags" value={formData.tags} onChange={handleFormChange}/></FormControl></SimpleGrid><FormControl mt={4}><FormLabel>Description</FormLabel><Textarea name="description" value={formData.description} onChange={handleFormChange}/></FormControl><FormControl display="flex" alignItems="center" mt={4}><FormLabel mb="0">Active:</FormLabel><Switch name="isActive" isChecked={formData.isActive} onChange={handleFormChange}/></FormControl></Box> {/* Removed Category FormControl */}
                <Box p={4} borderWidth="1px" borderRadius="md">
                    <Heading size="sm" mb={4}>Product Variants</Heading>
                    <RadioGroup onChange={(val) => setDefaultVariant(parseInt(val))} value={formData.variants.findIndex(v => v.isDefaultDisplay)?.toString() ?? "-1"}>
                      <VStack spacing={4} align="stretch">
                        {(formData.variants || []).map((variant, colorIndex) => (
                          (variant && variant.sizes) ? 
                          <Accordion key={colorIndex} defaultIndex={[0]} allowToggle borderWidth="1px" borderRadius="md" bg="gray.800">
                            <AccordionItem border="none">
                              <Flex align="center" p={2}>
                                <Radio value={colorIndex.toString()} mr={3} colorScheme="yellow"/><Tooltip label="Set as default display for shop page"><Icon as={FaStar} color={variant.isDefaultDisplay ? "yellow.400" : "gray.300"} mr={2}/></Tooltip>
                                <AccordionButton flex="1"><HStack w="full" spacing={4}><Box w="24px" h="24px" bg={variant.colorHex} borderRadius="full" border="1px solid" borderColor="gray.300"/><Text fontWeight="bold">{variant.colorName}</Text></HStack></AccordionButton><AccordionIcon /><CloseButton size="sm" onClick={() => handleRemoveColorVariant(colorIndex)} />
                              </Flex>
                              <AccordionPanel bg="gray.700" pb={4}>
                                <FormControl><FormLabel fontSize="sm">POD Product ID</FormLabel><Input size="sm" value={variant.podProductId || ''} onChange={(e) => { const newV = [...formData.variants]; newV[colorIndex].podProductId = e.target.value; setFormData(p => ({...p, variants: newV})); }} /></FormControl>
                                <Divider my={4} /><Heading size="xs" mb={3}>Image Gallery for {variant.colorName}</Heading>
                                <RadioGroup onChange={(idx) => setPrimaryImage(colorIndex, parseInt(idx))} value={variant.imageSet?.findIndex(img => img.isPrimary)?.toString() ?? "-1"}>
                                    <VStack align="stretch" spacing={2}>{variant.imageSet?.map((img, imgIndex) => (<HStack key={imgIndex}><Radio value={imgIndex.toString()} colorScheme="green"/><Input flex="1" size="sm" placeholder="https://image.url/shirt.png" value={img.url} onChange={(e) => handleImageSetUrlChange(colorIndex, imgIndex, e.target.value)} /><Image src={img.url} alt="Preview" boxSize="32px" objectFit="cover" borderRadius="sm" bg="gray.100" fallback={<Icon as={FaImage} color="gray.300" boxSize="32px" p={1}/>}/><ChakraIconButton size="sm" icon={<Icon as={FaTrashAlt}/>} onClick={() => removeImageFromSet(colorIndex, imgIndex)} isDisabled={variant.imageSet.length <= 1} /></HStack>))}</VStack>
                                </RadioGroup>
                                <Button size="sm" mt={3} onClick={() => addImageToSet(colorIndex)} leftIcon={<FaPlus/>}>Add Image</Button>
                                <Divider my={4} /><Heading size="xs" mb={3}>Available Sizes</Heading>
                                <Wrap spacing={4}>
                                  {variant.sizes?.map((size, sizeIndex) => (
                                    <WrapItem key={size.size}>
                                      {/* FINAL FIX: Changed background colors to be dark and removed the direct color prop on text */}
                                      <VStack p={2} borderWidth="1px" borderRadius="md" spacing={1} minW="180px" bg={size.inStock ? 'green.800' : 'red.800'}>
                                        <HStack justifyContent="space-between" w="100%">
                                          <Text fontWeight="bold">{size.size}</Text>
                                          <Switch size="sm" isChecked={size.inStock} onChange={e => handleSizeDetailChange(colorIndex, sizeIndex, 'inStock', e.target.checked)}/>
                                        </HStack>
                                        <FormControl isDisabled={!size.inStock}>
                                          <FormLabel fontSize="xs">SKU</FormLabel>
                                          <Input size="sm" value={size.sku} onChange={e => handleSizeDetailChange(colorIndex, sizeIndex, 'sku', e.target.value)} />
                                        </FormControl>
                                      </VStack>
                                    </WrapItem>
                                  ))}
                                </Wrap>
                              </AccordionPanel>
                            </AccordionItem>
                          </Accordion>
                          : null
                        ))}
                      </VStack>
                    </RadioGroup>
                    <Box p={4} borderWidth="1px" borderRadius="md" mt={6} bg="gray.700"><Heading size="xs" mb={3}>Add New Color Variant</Heading><SimpleGrid columns={{ base: 1, md: 3 }} spacing={3}><FormControl><FormLabel fontSize="sm">Color Name</FormLabel><Select size="sm" name="colorName" value={newColorData.colorName} onChange={handleNewColorFormChange} placeholder="Select...">{CORE_COLORS.map(c => <option key={c.name} value={c.name}>{c.name}</option>)}</Select></FormControl><FormControl><FormLabel fontSize="sm">Color Hex</FormLabel><HStack><Input size="sm" name="colorHex" value={newColorData.colorHex} onChange={handleNewColorFormChange}/><Box w="24px" h="24px" bg={newColorData.colorHex} borderRadius="sm" border="1px solid" borderColor="gray.300"/></HStack></FormControl><FormControl><FormLabel fontSize="sm">POD Product ID</FormLabel><Input size="sm" name="podProductId" value={newColorData.podProductId} onChange={handleNewColorFormChange}/></FormControl></SimpleGrid><Button mt={4} size="sm" colorScheme="teal" onClick={handleAddColorVariant} isDisabled={!newColorData.colorName}>Add This Color</Button></Box>
                </Box>
            </VStack>
            )}
          </ModalBody>
          <ModalFooter>
            <Button onClick={onClose} mr={3}>Cancel</Button>
            <Button colorScheme="brandAccentOrange" onClick={handleSubmit} isLoading={isModalLoading}>Save Changes</Button>
          </ModalFooter>
        </ModalContent>
      </Modal>
      {selectedProduct && (<Modal isOpen={isDeleteOpen} onClose={onDeleteClose} isCentered><ModalOverlay/><ModalContent><ModalHeader>Confirm Deletion</ModalHeader><ModalCloseButton/><ModalBody>Delete <strong>{selectedProduct.name}</strong>?</ModalBody><ModalFooter><Button onClick={onDeleteClose}>No</Button><Button colorScheme="red" onClick={handleDelete}>Yes</Button></ModalFooter></ModalContent></Modal>)}
    </Box>
  );
};

export default ProductManager;
import React from 'react';
import { Box, Image, Text, Heading, Skeleton, Icon, Flex } from '@chakra-ui/react';
import { Link as RouterLink } from 'react-router-dom';
import { FaImage } from 'react-icons/fa';

const ProductCard = ({ product }) => {
  if (!product) {
    return (
      <Box><Skeleton height="220px" borderRadius="lg"/><Skeleton height="20px" mt="4" /><Skeleton height="20px" mt="2" /></Box>
    );
  }

  const productUrl = product.slug ? `/product/${product.slug}` : '#';
  const isClickable = !!product.slug;

  return (
    // MODIFIED: Applied themed background and border colors
    <Box 
        as={isClickable ? RouterLink : 'div'} 
        to={productUrl} 
        borderWidth="2px" 
        borderRadius="lg" 
        overflow="hidden" 
        transition="all 0.2s ease-in-out" 
        _hover={isClickable ? { shadow: 'lg', transform: 'translateY(-4px)', borderColor: 'brand.accentYellow' } : {}} 
        cursor={isClickable ? 'pointer' : 'not-allowed'} 
        display="flex" 
        flexDirection="column" 
        bg="brand.cardBlue"
        borderColor="transparent"
    >
      {/* MODIFIED: Updated image container background */}
      <Box h="220px" bg="brand.secondary" p={4} display="flex" alignItems="center" justifyContent="center">
        <Image
          src={product.defaultImage}
          alt={`Image of ${product.name}`}
          objectFit="contain"
          w="100%"
          h="100%"
          fallback={<Icon as={FaImage} boxSize="50px" color="gray.500" />}
        />
      </Box>
      <Box p="4" mt="auto">
        {/* MODIFIED: Updated text colors for dark theme */}
        <Heading as="h3" size="sm" fontWeight="semibold" noOfLines={1} title={product.name} color="brand.textLight">
          {product.name}
        </Heading>
        <Text fontSize="sm" color="brand.textMuted" mt={1} noOfLines={2} h="40px">
          {product.description}
        </Text>
        <Text mt={2} fontSize="xl" color="brand.accentYellow" fontWeight="bold">
          ${product.basePrice.toFixed(2)}
        </Text>
      </Box>
    </Box>
  );
};

export default ProductCard;
// frontend/src/pages/ShopPage.jsx

import React, { useState, useEffect } from 'react';
import { Box, Heading, VStack, Spinner, Alert, AlertIcon, SimpleGrid, Text } from '@chakra-ui/react';
import { client } from '../api/client';
import ProductCard from '../components/shop/ProductCard';

const ShopPage = () => {
    const [products, setProducts] = useState([]); // Renamed from shopData
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');

    useEffect(() => {
        setLoading(true);
        // Changed API endpoint to fetch all products directly
        client.get('/storefront/products') 
            .then(res => setProducts(res.data)) // Updated state setter
            .catch(() => setError('Could not load products. Please try again later.'))
            .finally(() => setLoading(false));
    }, []);

    if (loading) {
        return (
            <VStack justifyContent="center" minH="60vh">
                <Spinner size="xl" color="brand.accentYellow" thickness="4px" />
                <Text mt={4} fontSize="lg" color="brand.textLight">Loading Collection...</Text>
            </VStack>
        );
    }

    if (error) {
        return (
            <Alert status="error" bg="red.900" borderRadius="md" p={6} borderWidth="1px" borderColor="red.500">
                <AlertIcon color="red.300" />
                <Text color="white">{error}</Text>
            </Alert>
        );
    }

    return (
        <VStack spacing={12} align="stretch">
            <Heading as="h1" size="2xl" color="brand.textLight" textAlign="center">
                Browse Our Collection
            </Heading>

            {products.length === 0 && !loading && ( // Updated state check
                <Box textAlign="center" py={10}>
                    <Text fontSize="xl" color="whiteAlpha.800">No products are currently available.</Text>
                </Box>
            )}

            {/* Removed category mapping, now directly maps over products */}
            <Box bg="brand.primaryLight" p={{base: 5, md: 8}} borderRadius="xl">
                <SimpleGrid columns={{ base: 1, sm: 2, md: 3, xl: 4 }} spacing={{ base: 6, md: 8 }}>
                    {products.map((product) => ( // Directly map products
                        <ProductCard key={product._id} product={product} />
                    ))}
                </SimpleGrid>
            </Box>
        </VStack>
    );
};

export default ShopPage;
import { useState, useEffect, useRef } from 'react';
import {
    Box, Heading, Text, VStack, Select, SimpleGrid, Image, Spinner, Alert,
    AlertIcon, Divider, useToast, Icon, Button, FormControl, FormLabel, Link as ChakraLink
} from '@chakra-ui/react';
import { useNavigate, useLocation, Link as RouterLink } from 'react-router-dom';
import { client } from '../api/client';
import { useAuth } from '../context/AuthProvider';
import { FaShoppingCart } from 'react-icons/fa';

const ThemedSelect = (props) => (
    <Select
        size="lg"
        bg="brand.primaryDark"
        borderColor="whiteAlpha.300"
        _hover={{ borderColor: "whiteAlpha.400" }}
        focusBorderColor="brand.accentYellow"
        {...props}
    />
);

export default function ProductStudio() {
    const { user } = useAuth();
    const navigate = useNavigate();
    const toast = useToast();
    const location = useLocation();

    const [products, setProducts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [designs, setDesigns] = useState([]);
    const [loadingDesigns, setLoadingDesigns] = useState(true);

    const [selectedProductId, setSelectedProductId] = useState('');
    const [selectedColor, setSelectedColor] = useState('');
    const [selectedSize, setSelectedSize] = useState('');
    const [selectedDesign, setSelectedDesign] = useState(null);
    
    const selectedProduct = products.find(p => p._id === selectedProductId);
    const availableColors = selectedProduct ? [...new Map(selectedProduct.variants.map(v => [v.colorName, v])).values()] : [];
    const selectedColorVariant = selectedProduct?.variants.find(v => v.colorName === selectedColor);
    const availableSizes = selectedColorVariant?.sizes?.filter(s => s.inStock) || [];
    const selectedSizeVariant = availableSizes.find(s => s.size === selectedSize);
    const finalVariant = selectedColorVariant && selectedSizeVariant ? { ...selectedColorVariant, ...selectedSizeVariant } : null;

    const canvasEl = useRef(null);
    const fabricCanvas = useRef(null);
    
    useEffect(() => {
        setLoading(true);
        client.get('/storefront/products')
            .then(res => {
                setProducts(res.data || []);
                // MODIFIED: Check for URL params after data loads
                const params = new URLSearchParams(location.search);
                const productId = params.get('productId');
                const color = params.get('color');
                const size = params.get('size');

                if (productId) setSelectedProductId(productId);
                if (color) setSelectedColor(color);
                if (size) setSelectedSize(size);
            })
            .catch(err => {
                console.error("Failed to fetch products:", err);
                toast({ title: "Error", description: "Could not load products. Please try again later.", status: "error" });
            })
            .finally(() => setLoading(false));
    }, [location.search, toast]);
    
    useEffect(() => {
        if (user) {
            setLoadingDesigns(true);
            client.get('/mydesigns').then(res => setDesigns(res.data || [])).finally(() => setLoadingDesigns(false));
        }
    }, [user]);

    useEffect(() => {
        const setupCanvas = (fabricInstance) => {
            if (!fabricCanvas.current && canvasEl.current) { fabricCanvas.current = new fabricInstance.Canvas(canvasEl.current, { width: 400, height: 400 }); }
            const FCanvas = fabricCanvas.current;
            if (!FCanvas) return;
            FCanvas.clear();
            
            const primaryImage = finalVariant?.imageSet?.find(img => img.isPrimary) || finalVariant?.imageSet?.[0];
            const mockupSrc = primaryImage?.url;

            if (mockupSrc) {
                fabricInstance.Image.fromURL(mockupSrc, (img) => { 
                    FCanvas.setBackgroundImage(img, FCanvas.renderAll.bind(FCanvas), { 
                        scaleX: FCanvas.width / img.width, 
                        scaleY: FCanvas.height / img.height 
                    }); 
                }, { crossOrigin: 'anonymous' });
            } else {
                FCanvas.setBackgroundImage(null, FCanvas.renderAll.bind(FCanvas));
            }
            
            FCanvas.getObjects('image').forEach(obj => FCanvas.remove(obj));
            if (selectedDesign?.imageDataUrl) {
                fabricInstance.Image.fromURL(selectedDesign.imageDataUrl, (img) => {
                    if (!img) return;
                    img.scaleToWidth(400 * 0.33);
                    img.set({ top: 400 * 0.24, left: (400 - img.getScaledWidth()) / 2 });
                    FCanvas.add(img);
                }, { crossOrigin: 'anonymous' });
            }
        };
        const pollForFabric = () => { if (window.fabric) setupCanvas(window.fabric); else setTimeout(pollForFabric, 100); };
        pollForFabric();
    }, [selectedDesign, finalVariant]);

    const handleProceedToCheckout = () => {
        if (!selectedDesign) { toast({ title: "Please select a design.", status: "warning", isClosable: true }); return; }
        if (!finalVariant) { toast({ title: "Please select all product options.", status: "warning", isClosable: true }); return; }
        
        const primaryImage = finalVariant.imageSet?.find(img => img.isPrimary) || finalVariant.imageSet?.[0];
        const checkoutItem = { 
            designId: selectedDesign._id, 
            productId: selectedProductId, 
            productName: selectedProduct.name, 
            variantSku: finalVariant.sku, 
            size: finalVariant.size, 
            color: finalVariant.colorName, 
            prompt: selectedDesign.prompt, 
            imageDataUrl: selectedDesign.imageDataUrl, 
            productImage: primaryImage?.url,
            unitPrice: (selectedProduct.basePrice + (finalVariant.priceModifier || 0))
        };
        localStorage.setItem('itemToCheckout', JSON.stringify(checkoutItem));
        navigate('/checkout');
    };
    
    const handleProductChange = (e) => {
        setSelectedProductId(e.target.value);
        setSelectedColor('');
        setSelectedSize('');
    };
    const handleColorChange = (e) => {
        setSelectedColor(e.target.value);
        setSelectedSize('');
    };

    return (
        <VStack spacing={8} align="stretch">
            <Heading as="h1" size="2xl" color="brand.textLight">Customize Your Apparel</Heading>
            
            <Box bg="brand.cardBlue" p={{base: 5, md: 8}} borderRadius="xl">
                <VStack spacing={6} align="stretch">
                    <Heading as="h2" size="xl" color="brand.textLight">1. Choose Your Apparel</Heading>
                    {loading ? <Spinner color="brand.accentYellow" /> :
                    <SimpleGrid columns={{ base: 1, md: 3 }} spacing={6}>
                        <FormControl><FormLabel color="whiteAlpha.800">Product</FormLabel><ThemedSelect value={selectedProductId} onChange={handleProductChange} placeholder="Select Product">{products.map(p => <option key={p._id} value={p._id}>{p.name}</option>)}</ThemedSelect></FormControl>
                        <FormControl><FormLabel color="whiteAlpha.800">Color</FormLabel><ThemedSelect value={selectedColor} onChange={handleColorChange} placeholder="Select Color" isDisabled={!selectedProductId}>{availableColors.map(c => <option key={c.colorName} value={c.colorName}>{c.colorName}</option>)}</ThemedSelect></FormControl>
                        <FormControl><FormLabel color="whiteAlpha.800">Size</FormLabel><ThemedSelect value={selectedSize} onChange={(e) => setSelectedSize(e.target.value)} placeholder="Select Size" isDisabled={!selectedColor}>{availableSizes.map(s => <option key={s.sku} value={s.size}>{s.size}</option>)}</ThemedSelect></FormControl>
                    </SimpleGrid>
                    }
                </VStack>
            </Box>

            <Box bg="brand.cardBlue" p={{base: 5, md: 8}} borderRadius="xl">
                <VStack spacing={6} align="stretch">
                    <Heading as="h2" size="xl" color="brand.textLight">2. Choose Your Saved Design</Heading>
                    {loadingDesigns ? <Spinner color="brand.accentYellow"/> : !designs.length ? (
                        <Text color="whiteAlpha.800" fontSize="lg">You have no saved designs. <ChakraLink as={RouterLink} to="/generate" color="brand.accentYellow" fontWeight="bold">Generate one now!</ChakraLink></Text>
                    ) : (
                        <SimpleGrid columns={{ base: 2, sm: 3, md: 5, lg: 6 }} spacing={4}>
                            {designs.map(design => (
                                <Box key={design._id} p={1} bg="brand.secondary" borderWidth="3px" borderRadius="lg" onClick={() => setSelectedDesign(design)} cursor="pointer" borderColor={selectedDesign?._id === design._id ? "brand.accentYellow" : "transparent"} transition="border-color 0.2s ease-in-out">
                                    <Image src={design.imageDataUrl} borderRadius="md" />
                                </Box>
                            ))}
                        </SimpleGrid>
                    )}
                </VStack>
            </Box>
            
            <Box bg="brand.cardBlue" p={{base: 5, md: 8}} borderRadius="xl">
                <VStack spacing={6} align="stretch">
                    <Heading as="h2" size="xl" color="brand.textLight" textAlign="center">3. Preview & Checkout</Heading>
                    <Box w="400px" h="400px" bg="rgba(0,0,0,0.2)" mx="auto" borderRadius="md" borderWidth="1px" borderColor="whiteAlpha.300">
                        <canvas ref={canvasEl} />
                    </Box>
                    {selectedDesign && finalVariant ? (
                        <VStack spacing={4} mt={4}>
                            <Text fontSize="xl" fontWeight="medium" color="brand.textLight">Your design on a {finalVariant.size} {finalVariant.colorName} shirt.</Text>
                            <Button colorScheme="brandAccentOrange" size="lg" onClick={handleProceedToCheckout} leftIcon={<Icon as={FaShoppingCart} />}>Proceed to Checkout</Button>
                        </VStack>
                    ) : (
                        <Alert status="info" borderRadius="md" maxW="lg" mx="auto" bg="blue.900" borderWidth="1px" borderColor="blue.500">
                            <AlertIcon color="blue.300" />
                            <Text color="whiteAlpha.900">Please select an apparel option and a design to continue.</Text>
                        </Alert>
                    )}
                </VStack>
            </Box>
        </VStack>
    );
}
